// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: InventoryItem.proto

#ifndef PROTOBUF_InventoryItem_2eproto__INCLUDED
#define PROTOBUF_InventoryItem_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace swgemurpcserver {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_InventoryItem_2eproto();
void protobuf_AssignDesc_InventoryItem_2eproto();
void protobuf_ShutdownFile_InventoryItem_2eproto();

class CharacterInventoryItem;
class ArmorItem;
class WeaponItem;
class ResourceContainerItem;
class ResourceAttribute;
class ResourceSpawnClass;
class FactoryCrateItem;
class PharmaceuticalItem;
class RangedStimPackItem;
class DotPackItem;
class EnhancePackItem;
class RevivePackItem;
class WoundPackItem;
class CraftingComponentItem;
class CraftingComponentAttribute;
class ManufacturingSchematicItem;
class IngredientItem;
class BlueprintEntryItem;

enum PharmaceuticalItem_PharmaceuticalItemType {
  PharmaceuticalItem_PharmaceuticalItemType_UNKNOWN = -1,
  PharmaceuticalItem_PharmaceuticalItemType_CUREPACK = 0,
  PharmaceuticalItem_PharmaceuticalItemType_DOTPACK = 1,
  PharmaceuticalItem_PharmaceuticalItemType_ENHANCEPACK = 2,
  PharmaceuticalItem_PharmaceuticalItemType_RANGEDSTIMPACK = 3,
  PharmaceuticalItem_PharmaceuticalItemType_REVIVIEPACK = 4,
  PharmaceuticalItem_PharmaceuticalItemType_STIMPACK = 5,
  PharmaceuticalItem_PharmaceuticalItemType_WOUNDPACK = 6
};
bool PharmaceuticalItem_PharmaceuticalItemType_IsValid(int value);
const PharmaceuticalItem_PharmaceuticalItemType PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_MIN = PharmaceuticalItem_PharmaceuticalItemType_UNKNOWN;
const PharmaceuticalItem_PharmaceuticalItemType PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_MAX = PharmaceuticalItem_PharmaceuticalItemType_WOUNDPACK;
const int PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_ARRAYSIZE = PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PharmaceuticalItem_PharmaceuticalItemType_descriptor();
inline const ::std::string& PharmaceuticalItem_PharmaceuticalItemType_Name(PharmaceuticalItem_PharmaceuticalItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PharmaceuticalItem_PharmaceuticalItemType_descriptor(), value);
}
inline bool PharmaceuticalItem_PharmaceuticalItemType_Parse(
    const ::std::string& name, PharmaceuticalItem_PharmaceuticalItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PharmaceuticalItem_PharmaceuticalItemType>(
    PharmaceuticalItem_PharmaceuticalItemType_descriptor(), name, value);
}
// ===================================================================

class CharacterInventoryItem : public ::google::protobuf::Message {
 public:
  CharacterInventoryItem();
  virtual ~CharacterInventoryItem();

  CharacterInventoryItem(const CharacterInventoryItem& from);

  inline CharacterInventoryItem& operator=(const CharacterInventoryItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CharacterInventoryItem& default_instance();

  void Swap(CharacterInventoryItem* other);

  // implements Message ----------------------------------------------

  CharacterInventoryItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CharacterInventoryItem& from);
  void MergeFrom(const CharacterInventoryItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 object_id = 1;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  inline ::google::protobuf::uint64 object_id() const;
  inline void set_object_id(::google::protobuf::uint64 value);

  // required string appearance_file_name = 2;
  inline bool has_appearance_file_name() const;
  inline void clear_appearance_file_name();
  static const int kAppearanceFileNameFieldNumber = 2;
  inline const ::std::string& appearance_file_name() const;
  inline void set_appearance_file_name(const ::std::string& value);
  inline void set_appearance_file_name(const char* value);
  inline void set_appearance_file_name(const char* value, size_t size);
  inline ::std::string* mutable_appearance_file_name();
  inline ::std::string* release_appearance_file_name();
  inline void set_allocated_appearance_file_name(::std::string* appearance_file_name);

  // required string object_name = 3;
  inline bool has_object_name() const;
  inline void clear_object_name();
  static const int kObjectNameFieldNumber = 3;
  inline const ::std::string& object_name() const;
  inline void set_object_name(const ::std::string& value);
  inline void set_object_name(const char* value);
  inline void set_object_name(const char* value, size_t size);
  inline ::std::string* mutable_object_name();
  inline ::std::string* release_object_name();
  inline void set_allocated_object_name(::std::string* object_name);

  // required string display_name = 4;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // required string description = 5;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 5;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required string crafter_name = 6;
  inline bool has_crafter_name() const;
  inline void clear_crafter_name();
  static const int kCrafterNameFieldNumber = 6;
  inline const ::std::string& crafter_name() const;
  inline void set_crafter_name(const ::std::string& value);
  inline void set_crafter_name(const char* value);
  inline void set_crafter_name(const char* value, size_t size);
  inline ::std::string* mutable_crafter_name();
  inline ::std::string* release_crafter_name();
  inline void set_allocated_crafter_name(::std::string* crafter_name);

  // required string serial_number = 7;
  inline bool has_serial_number() const;
  inline void clear_serial_number();
  static const int kSerialNumberFieldNumber = 7;
  inline const ::std::string& serial_number() const;
  inline void set_serial_number(const ::std::string& value);
  inline void set_serial_number(const char* value);
  inline void set_serial_number(const char* value, size_t size);
  inline ::std::string* mutable_serial_number();
  inline ::std::string* release_serial_number();
  inline void set_allocated_serial_number(::std::string* serial_number);

  // optional int32 max_condition = 8;
  inline bool has_max_condition() const;
  inline void clear_max_condition();
  static const int kMaxConditionFieldNumber = 8;
  inline ::google::protobuf::int32 max_condition() const;
  inline void set_max_condition(::google::protobuf::int32 value);

  // optional int32 condition = 9;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 9;
  inline ::google::protobuf::int32 condition() const;
  inline void set_condition(::google::protobuf::int32 value);

  // optional fixed32 containment_location = 10;
  inline bool has_containment_location() const;
  inline void clear_containment_location();
  static const int kContainmentLocationFieldNumber = 10;
  inline ::google::protobuf::uint32 containment_location() const;
  inline void set_containment_location(::google::protobuf::uint32 value);

  // optional string template_file_name = 11;
  inline bool has_template_file_name() const;
  inline void clear_template_file_name();
  static const int kTemplateFileNameFieldNumber = 11;
  inline const ::std::string& template_file_name() const;
  inline void set_template_file_name(const ::std::string& value);
  inline void set_template_file_name(const char* value);
  inline void set_template_file_name(const char* value, size_t size);
  inline ::std::string* mutable_template_file_name();
  inline ::std::string* release_template_file_name();
  inline void set_allocated_template_file_name(::std::string* template_file_name);

  // optional string portals_file_name = 12;
  inline bool has_portals_file_name() const;
  inline void clear_portals_file_name();
  static const int kPortalsFileNameFieldNumber = 12;
  inline const ::std::string& portals_file_name() const;
  inline void set_portals_file_name(const ::std::string& value);
  inline void set_portals_file_name(const char* value);
  inline void set_portals_file_name(const char* value, size_t size);
  inline ::std::string* mutable_portals_file_name();
  inline ::std::string* release_portals_file_name();
  inline void set_allocated_portals_file_name(::std::string* portals_file_name);

  // optional .swgemurpcserver.rpc.ArmorItem armor_details = 13;
  inline bool has_armor_details() const;
  inline void clear_armor_details();
  static const int kArmorDetailsFieldNumber = 13;
  inline const ::swgemurpcserver::rpc::ArmorItem& armor_details() const;
  inline ::swgemurpcserver::rpc::ArmorItem* mutable_armor_details();
  inline ::swgemurpcserver::rpc::ArmorItem* release_armor_details();
  inline void set_allocated_armor_details(::swgemurpcserver::rpc::ArmorItem* armor_details);

  // optional .swgemurpcserver.rpc.WeaponItem weapon_details = 14;
  inline bool has_weapon_details() const;
  inline void clear_weapon_details();
  static const int kWeaponDetailsFieldNumber = 14;
  inline const ::swgemurpcserver::rpc::WeaponItem& weapon_details() const;
  inline ::swgemurpcserver::rpc::WeaponItem* mutable_weapon_details();
  inline ::swgemurpcserver::rpc::WeaponItem* release_weapon_details();
  inline void set_allocated_weapon_details(::swgemurpcserver::rpc::WeaponItem* weapon_details);

  // optional .swgemurpcserver.rpc.ResourceContainerItem resource_details = 15;
  inline bool has_resource_details() const;
  inline void clear_resource_details();
  static const int kResourceDetailsFieldNumber = 15;
  inline const ::swgemurpcserver::rpc::ResourceContainerItem& resource_details() const;
  inline ::swgemurpcserver::rpc::ResourceContainerItem* mutable_resource_details();
  inline ::swgemurpcserver::rpc::ResourceContainerItem* release_resource_details();
  inline void set_allocated_resource_details(::swgemurpcserver::rpc::ResourceContainerItem* resource_details);

  // optional .swgemurpcserver.rpc.FactoryCrateItem factory_crate_details = 16;
  inline bool has_factory_crate_details() const;
  inline void clear_factory_crate_details();
  static const int kFactoryCrateDetailsFieldNumber = 16;
  inline const ::swgemurpcserver::rpc::FactoryCrateItem& factory_crate_details() const;
  inline ::swgemurpcserver::rpc::FactoryCrateItem* mutable_factory_crate_details();
  inline ::swgemurpcserver::rpc::FactoryCrateItem* release_factory_crate_details();
  inline void set_allocated_factory_crate_details(::swgemurpcserver::rpc::FactoryCrateItem* factory_crate_details);

  // optional .swgemurpcserver.rpc.PharmaceuticalItem pharmaceutical_details = 17;
  inline bool has_pharmaceutical_details() const;
  inline void clear_pharmaceutical_details();
  static const int kPharmaceuticalDetailsFieldNumber = 17;
  inline const ::swgemurpcserver::rpc::PharmaceuticalItem& pharmaceutical_details() const;
  inline ::swgemurpcserver::rpc::PharmaceuticalItem* mutable_pharmaceutical_details();
  inline ::swgemurpcserver::rpc::PharmaceuticalItem* release_pharmaceutical_details();
  inline void set_allocated_pharmaceutical_details(::swgemurpcserver::rpc::PharmaceuticalItem* pharmaceutical_details);

  // optional .swgemurpcserver.rpc.CraftingComponentItem crafting_component_details = 18;
  inline bool has_crafting_component_details() const;
  inline void clear_crafting_component_details();
  static const int kCraftingComponentDetailsFieldNumber = 18;
  inline const ::swgemurpcserver::rpc::CraftingComponentItem& crafting_component_details() const;
  inline ::swgemurpcserver::rpc::CraftingComponentItem* mutable_crafting_component_details();
  inline ::swgemurpcserver::rpc::CraftingComponentItem* release_crafting_component_details();
  inline void set_allocated_crafting_component_details(::swgemurpcserver::rpc::CraftingComponentItem* crafting_component_details);

  // optional .swgemurpcserver.rpc.ManufacturingSchematicItem mfg_schem_details = 19;
  inline bool has_mfg_schem_details() const;
  inline void clear_mfg_schem_details();
  static const int kMfgSchemDetailsFieldNumber = 19;
  inline const ::swgemurpcserver::rpc::ManufacturingSchematicItem& mfg_schem_details() const;
  inline ::swgemurpcserver::rpc::ManufacturingSchematicItem* mutable_mfg_schem_details();
  inline ::swgemurpcserver::rpc::ManufacturingSchematicItem* release_mfg_schem_details();
  inline void set_allocated_mfg_schem_details(::swgemurpcserver::rpc::ManufacturingSchematicItem* mfg_schem_details);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.CharacterInventoryItem)
 private:
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_appearance_file_name();
  inline void clear_has_appearance_file_name();
  inline void set_has_object_name();
  inline void clear_has_object_name();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_crafter_name();
  inline void clear_has_crafter_name();
  inline void set_has_serial_number();
  inline void clear_has_serial_number();
  inline void set_has_max_condition();
  inline void clear_has_max_condition();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_containment_location();
  inline void clear_has_containment_location();
  inline void set_has_template_file_name();
  inline void clear_has_template_file_name();
  inline void set_has_portals_file_name();
  inline void clear_has_portals_file_name();
  inline void set_has_armor_details();
  inline void clear_has_armor_details();
  inline void set_has_weapon_details();
  inline void clear_has_weapon_details();
  inline void set_has_resource_details();
  inline void clear_has_resource_details();
  inline void set_has_factory_crate_details();
  inline void clear_has_factory_crate_details();
  inline void set_has_pharmaceutical_details();
  inline void clear_has_pharmaceutical_details();
  inline void set_has_crafting_component_details();
  inline void clear_has_crafting_component_details();
  inline void set_has_mfg_schem_details();
  inline void clear_has_mfg_schem_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 object_id_;
  ::std::string* appearance_file_name_;
  ::std::string* object_name_;
  ::std::string* display_name_;
  ::std::string* description_;
  ::std::string* crafter_name_;
  ::std::string* serial_number_;
  ::google::protobuf::int32 max_condition_;
  ::google::protobuf::int32 condition_;
  ::std::string* template_file_name_;
  ::std::string* portals_file_name_;
  ::swgemurpcserver::rpc::ArmorItem* armor_details_;
  ::swgemurpcserver::rpc::WeaponItem* weapon_details_;
  ::swgemurpcserver::rpc::ResourceContainerItem* resource_details_;
  ::swgemurpcserver::rpc::FactoryCrateItem* factory_crate_details_;
  ::swgemurpcserver::rpc::PharmaceuticalItem* pharmaceutical_details_;
  ::swgemurpcserver::rpc::CraftingComponentItem* crafting_component_details_;
  ::swgemurpcserver::rpc::ManufacturingSchematicItem* mfg_schem_details_;
  ::google::protobuf::uint32 containment_location_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static CharacterInventoryItem* default_instance_;
};
// -------------------------------------------------------------------

class ArmorItem : public ::google::protobuf::Message {
 public:
  ArmorItem();
  virtual ~ArmorItem();

  ArmorItem(const ArmorItem& from);

  inline ArmorItem& operator=(const ArmorItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmorItem& default_instance();

  void Swap(ArmorItem* other);

  // implements Message ----------------------------------------------

  ArmorItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArmorItem& from);
  void MergeFrom(const ArmorItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float kinetic = 1;
  inline bool has_kinetic() const;
  inline void clear_kinetic();
  static const int kKineticFieldNumber = 1;
  inline float kinetic() const;
  inline void set_kinetic(float value);

  // required float energy = 2;
  inline bool has_energy() const;
  inline void clear_energy();
  static const int kEnergyFieldNumber = 2;
  inline float energy() const;
  inline void set_energy(float value);

  // required float electricity = 3;
  inline bool has_electricity() const;
  inline void clear_electricity();
  static const int kElectricityFieldNumber = 3;
  inline float electricity() const;
  inline void set_electricity(float value);

  // required float stun = 4;
  inline bool has_stun() const;
  inline void clear_stun();
  static const int kStunFieldNumber = 4;
  inline float stun() const;
  inline void set_stun(float value);

  // required float blast = 5;
  inline bool has_blast() const;
  inline void clear_blast();
  static const int kBlastFieldNumber = 5;
  inline float blast() const;
  inline void set_blast(float value);

  // required float heat = 6;
  inline bool has_heat() const;
  inline void clear_heat();
  static const int kHeatFieldNumber = 6;
  inline float heat() const;
  inline void set_heat(float value);

  // required float cold = 7;
  inline bool has_cold() const;
  inline void clear_cold();
  static const int kColdFieldNumber = 7;
  inline float cold() const;
  inline void set_cold(float value);

  // required float acid = 8;
  inline bool has_acid() const;
  inline void clear_acid();
  static const int kAcidFieldNumber = 8;
  inline float acid() const;
  inline void set_acid(float value);

  // required float lighsaber = 9;
  inline bool has_lighsaber() const;
  inline void clear_lighsaber();
  static const int kLighsaberFieldNumber = 9;
  inline float lighsaber() const;
  inline void set_lighsaber(float value);

  // required int32 health_encumberance = 10;
  inline bool has_health_encumberance() const;
  inline void clear_health_encumberance();
  static const int kHealthEncumberanceFieldNumber = 10;
  inline ::google::protobuf::int32 health_encumberance() const;
  inline void set_health_encumberance(::google::protobuf::int32 value);

  // required int32 action_encumberance = 11;
  inline bool has_action_encumberance() const;
  inline void clear_action_encumberance();
  static const int kActionEncumberanceFieldNumber = 11;
  inline ::google::protobuf::int32 action_encumberance() const;
  inline void set_action_encumberance(::google::protobuf::int32 value);

  // required int32 mind_encumberance = 12;
  inline bool has_mind_encumberance() const;
  inline void clear_mind_encumberance();
  static const int kMindEncumberanceFieldNumber = 12;
  inline ::google::protobuf::int32 mind_encumberance() const;
  inline void set_mind_encumberance(::google::protobuf::int32 value);

  // required int32 rating = 13;
  inline bool has_rating() const;
  inline void clear_rating();
  static const int kRatingFieldNumber = 13;
  inline ::google::protobuf::int32 rating() const;
  inline void set_rating(::google::protobuf::int32 value);

  // repeated int32 hit_location = 14 [packed = true];
  inline int hit_location_size() const;
  inline void clear_hit_location();
  static const int kHitLocationFieldNumber = 14;
  inline ::google::protobuf::int32 hit_location(int index) const;
  inline void set_hit_location(int index, ::google::protobuf::int32 value);
  inline void add_hit_location(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      hit_location() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_hit_location();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.ArmorItem)
 private:
  inline void set_has_kinetic();
  inline void clear_has_kinetic();
  inline void set_has_energy();
  inline void clear_has_energy();
  inline void set_has_electricity();
  inline void clear_has_electricity();
  inline void set_has_stun();
  inline void clear_has_stun();
  inline void set_has_blast();
  inline void clear_has_blast();
  inline void set_has_heat();
  inline void clear_has_heat();
  inline void set_has_cold();
  inline void clear_has_cold();
  inline void set_has_acid();
  inline void clear_has_acid();
  inline void set_has_lighsaber();
  inline void clear_has_lighsaber();
  inline void set_has_health_encumberance();
  inline void clear_has_health_encumberance();
  inline void set_has_action_encumberance();
  inline void clear_has_action_encumberance();
  inline void set_has_mind_encumberance();
  inline void clear_has_mind_encumberance();
  inline void set_has_rating();
  inline void clear_has_rating();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float kinetic_;
  float energy_;
  float electricity_;
  float stun_;
  float blast_;
  float heat_;
  float cold_;
  float acid_;
  float lighsaber_;
  ::google::protobuf::int32 health_encumberance_;
  ::google::protobuf::int32 action_encumberance_;
  ::google::protobuf::int32 mind_encumberance_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > hit_location_;
  mutable int _hit_location_cached_byte_size_;
  ::google::protobuf::int32 rating_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static ArmorItem* default_instance_;
};
// -------------------------------------------------------------------

class WeaponItem : public ::google::protobuf::Message {
 public:
  WeaponItem();
  virtual ~WeaponItem();

  WeaponItem(const WeaponItem& from);

  inline WeaponItem& operator=(const WeaponItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeaponItem& default_instance();

  void Swap(WeaponItem* other);

  // implements Message ----------------------------------------------

  WeaponItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WeaponItem& from);
  void MergeFrom(const WeaponItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 point_blank_accuracy = 1;
  inline bool has_point_blank_accuracy() const;
  inline void clear_point_blank_accuracy();
  static const int kPointBlankAccuracyFieldNumber = 1;
  inline ::google::protobuf::int32 point_blank_accuracy() const;
  inline void set_point_blank_accuracy(::google::protobuf::int32 value);

  // required int32 point_blank_range = 2;
  inline bool has_point_blank_range() const;
  inline void clear_point_blank_range();
  static const int kPointBlankRangeFieldNumber = 2;
  inline ::google::protobuf::int32 point_blank_range() const;
  inline void set_point_blank_range(::google::protobuf::int32 value);

  // required int32 ideal_range = 3;
  inline bool has_ideal_range() const;
  inline void clear_ideal_range();
  static const int kIdealRangeFieldNumber = 3;
  inline ::google::protobuf::int32 ideal_range() const;
  inline void set_ideal_range(::google::protobuf::int32 value);

  // required int32 max_range = 4;
  inline bool has_max_range() const;
  inline void clear_max_range();
  static const int kMaxRangeFieldNumber = 4;
  inline ::google::protobuf::int32 max_range() const;
  inline void set_max_range(::google::protobuf::int32 value);

  // required int32 ideal_accuracy = 5;
  inline bool has_ideal_accuracy() const;
  inline void clear_ideal_accuracy();
  static const int kIdealAccuracyFieldNumber = 5;
  inline ::google::protobuf::int32 ideal_accuracy() const;
  inline void set_ideal_accuracy(::google::protobuf::int32 value);

  // required int32 max_range_accuracy = 6;
  inline bool has_max_range_accuracy() const;
  inline void clear_max_range_accuracy();
  static const int kMaxRangeAccuracyFieldNumber = 6;
  inline ::google::protobuf::int32 max_range_accuracy() const;
  inline void set_max_range_accuracy(::google::protobuf::int32 value);

  // required int32 armor_piercing = 7;
  inline bool has_armor_piercing() const;
  inline void clear_armor_piercing();
  static const int kArmorPiercingFieldNumber = 7;
  inline ::google::protobuf::int32 armor_piercing() const;
  inline void set_armor_piercing(::google::protobuf::int32 value);

  // required float attack_speed = 8;
  inline bool has_attack_speed() const;
  inline void clear_attack_speed();
  static const int kAttackSpeedFieldNumber = 8;
  inline float attack_speed() const;
  inline void set_attack_speed(float value);

  // required float max_damage = 9;
  inline bool has_max_damage() const;
  inline void clear_max_damage();
  static const int kMaxDamageFieldNumber = 9;
  inline float max_damage() const;
  inline void set_max_damage(float value);

  // required float min_damage = 10;
  inline bool has_min_damage() const;
  inline void clear_min_damage();
  static const int kMinDamageFieldNumber = 10;
  inline float min_damage() const;
  inline void set_min_damage(float value);

  // required float wound_ratio = 11;
  inline bool has_wound_ratio() const;
  inline void clear_wound_ratio();
  static const int kWoundRatioFieldNumber = 11;
  inline float wound_ratio() const;
  inline void set_wound_ratio(float value);

  // required float damage_radius = 12;
  inline bool has_damage_radius() const;
  inline void clear_damage_radius();
  static const int kDamageRadiusFieldNumber = 12;
  inline float damage_radius() const;
  inline void set_damage_radius(float value);

  // required int32 health_attack_cost = 13;
  inline bool has_health_attack_cost() const;
  inline void clear_health_attack_cost();
  static const int kHealthAttackCostFieldNumber = 13;
  inline ::google::protobuf::int32 health_attack_cost() const;
  inline void set_health_attack_cost(::google::protobuf::int32 value);

  // required int32 action_attack_cost = 14;
  inline bool has_action_attack_cost() const;
  inline void clear_action_attack_cost();
  static const int kActionAttackCostFieldNumber = 14;
  inline ::google::protobuf::int32 action_attack_cost() const;
  inline void set_action_attack_cost(::google::protobuf::int32 value);

  // required int32 mind_attack_cost = 15;
  inline bool has_mind_attack_cost() const;
  inline void clear_mind_attack_cost();
  static const int kMindAttackCostFieldNumber = 15;
  inline ::google::protobuf::int32 mind_attack_cost() const;
  inline void set_mind_attack_cost(::google::protobuf::int32 value);

  // required int32 force_attack_cost = 16;
  inline bool has_force_attack_cost() const;
  inline void clear_force_attack_cost();
  static const int kForceAttackCostFieldNumber = 16;
  inline ::google::protobuf::int32 force_attack_cost() const;
  inline void set_force_attack_cost(::google::protobuf::int32 value);

  // required int32 damage_type = 17;
  inline bool has_damage_type() const;
  inline void clear_damage_type();
  static const int kDamageTypeFieldNumber = 17;
  inline ::google::protobuf::int32 damage_type() const;
  inline void set_damage_type(::google::protobuf::int32 value);

  // required string weapon_type = 18;
  inline bool has_weapon_type() const;
  inline void clear_weapon_type();
  static const int kWeaponTypeFieldNumber = 18;
  inline const ::std::string& weapon_type() const;
  inline void set_weapon_type(const ::std::string& value);
  inline void set_weapon_type(const char* value);
  inline void set_weapon_type(const char* value, size_t size);
  inline ::std::string* mutable_weapon_type();
  inline ::std::string* release_weapon_type();
  inline void set_allocated_weapon_type(::std::string* weapon_type);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.WeaponItem)
 private:
  inline void set_has_point_blank_accuracy();
  inline void clear_has_point_blank_accuracy();
  inline void set_has_point_blank_range();
  inline void clear_has_point_blank_range();
  inline void set_has_ideal_range();
  inline void clear_has_ideal_range();
  inline void set_has_max_range();
  inline void clear_has_max_range();
  inline void set_has_ideal_accuracy();
  inline void clear_has_ideal_accuracy();
  inline void set_has_max_range_accuracy();
  inline void clear_has_max_range_accuracy();
  inline void set_has_armor_piercing();
  inline void clear_has_armor_piercing();
  inline void set_has_attack_speed();
  inline void clear_has_attack_speed();
  inline void set_has_max_damage();
  inline void clear_has_max_damage();
  inline void set_has_min_damage();
  inline void clear_has_min_damage();
  inline void set_has_wound_ratio();
  inline void clear_has_wound_ratio();
  inline void set_has_damage_radius();
  inline void clear_has_damage_radius();
  inline void set_has_health_attack_cost();
  inline void clear_has_health_attack_cost();
  inline void set_has_action_attack_cost();
  inline void clear_has_action_attack_cost();
  inline void set_has_mind_attack_cost();
  inline void clear_has_mind_attack_cost();
  inline void set_has_force_attack_cost();
  inline void clear_has_force_attack_cost();
  inline void set_has_damage_type();
  inline void clear_has_damage_type();
  inline void set_has_weapon_type();
  inline void clear_has_weapon_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 point_blank_accuracy_;
  ::google::protobuf::int32 point_blank_range_;
  ::google::protobuf::int32 ideal_range_;
  ::google::protobuf::int32 max_range_;
  ::google::protobuf::int32 ideal_accuracy_;
  ::google::protobuf::int32 max_range_accuracy_;
  ::google::protobuf::int32 armor_piercing_;
  float attack_speed_;
  float max_damage_;
  float min_damage_;
  float wound_ratio_;
  float damage_radius_;
  ::google::protobuf::int32 health_attack_cost_;
  ::google::protobuf::int32 action_attack_cost_;
  ::google::protobuf::int32 mind_attack_cost_;
  ::google::protobuf::int32 force_attack_cost_;
  ::std::string* weapon_type_;
  ::google::protobuf::int32 damage_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static WeaponItem* default_instance_;
};
// -------------------------------------------------------------------

class ResourceContainerItem : public ::google::protobuf::Message {
 public:
  ResourceContainerItem();
  virtual ~ResourceContainerItem();

  ResourceContainerItem(const ResourceContainerItem& from);

  inline ResourceContainerItem& operator=(const ResourceContainerItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceContainerItem& default_instance();

  void Swap(ResourceContainerItem* other);

  // implements Message ----------------------------------------------

  ResourceContainerItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceContainerItem& from);
  void MergeFrom(const ResourceContainerItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required fixed64 resource_id = 3;
  inline bool has_resource_id() const;
  inline void clear_resource_id();
  static const int kResourceIdFieldNumber = 3;
  inline ::google::protobuf::uint64 resource_id() const;
  inline void set_resource_id(::google::protobuf::uint64 value);

  // required int32 count = 4;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 4;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // repeated .swgemurpcserver.rpc.ResourceSpawnClass classes = 5;
  inline int classes_size() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 5;
  inline const ::swgemurpcserver::rpc::ResourceSpawnClass& classes(int index) const;
  inline ::swgemurpcserver::rpc::ResourceSpawnClass* mutable_classes(int index);
  inline ::swgemurpcserver::rpc::ResourceSpawnClass* add_classes();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceSpawnClass >&
      classes() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceSpawnClass >*
      mutable_classes();

  // repeated .swgemurpcserver.rpc.ResourceAttribute attributes = 6;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 6;
  inline const ::swgemurpcserver::rpc::ResourceAttribute& attributes(int index) const;
  inline ::swgemurpcserver::rpc::ResourceAttribute* mutable_attributes(int index);
  inline ::swgemurpcserver::rpc::ResourceAttribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceAttribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceAttribute >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.ResourceContainerItem)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_resource_id();
  inline void clear_has_resource_id();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* type_;
  ::google::protobuf::uint64 resource_id_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceSpawnClass > classes_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceAttribute > attributes_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static ResourceContainerItem* default_instance_;
};
// -------------------------------------------------------------------

class ResourceAttribute : public ::google::protobuf::Message {
 public:
  ResourceAttribute();
  virtual ~ResourceAttribute();

  ResourceAttribute(const ResourceAttribute& from);

  inline ResourceAttribute& operator=(const ResourceAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceAttribute& default_instance();

  void Swap(ResourceAttribute* other);

  // implements Message ----------------------------------------------

  ResourceAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceAttribute& from);
  void MergeFrom(const ResourceAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.ResourceAttribute)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static ResourceAttribute* default_instance_;
};
// -------------------------------------------------------------------

class ResourceSpawnClass : public ::google::protobuf::Message {
 public:
  ResourceSpawnClass();
  virtual ~ResourceSpawnClass();

  ResourceSpawnClass(const ResourceSpawnClass& from);

  inline ResourceSpawnClass& operator=(const ResourceSpawnClass& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResourceSpawnClass& default_instance();

  void Swap(ResourceSpawnClass* other);

  // implements Message ----------------------------------------------

  ResourceSpawnClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResourceSpawnClass& from);
  void MergeFrom(const ResourceSpawnClass& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string class_name = 1;
  inline bool has_class_name() const;
  inline void clear_class_name();
  static const int kClassNameFieldNumber = 1;
  inline const ::std::string& class_name() const;
  inline void set_class_name(const ::std::string& value);
  inline void set_class_name(const char* value);
  inline void set_class_name(const char* value, size_t size);
  inline ::std::string* mutable_class_name();
  inline ::std::string* release_class_name();
  inline void set_allocated_class_name(::std::string* class_name);

  // required string stf_class = 2;
  inline bool has_stf_class() const;
  inline void clear_stf_class();
  static const int kStfClassFieldNumber = 2;
  inline const ::std::string& stf_class() const;
  inline void set_stf_class(const ::std::string& value);
  inline void set_stf_class(const char* value);
  inline void set_stf_class(const char* value, size_t size);
  inline ::std::string* mutable_stf_class();
  inline ::std::string* release_stf_class();
  inline void set_allocated_stf_class(::std::string* stf_class);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.ResourceSpawnClass)
 private:
  inline void set_has_class_name();
  inline void clear_has_class_name();
  inline void set_has_stf_class();
  inline void clear_has_stf_class();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* class_name_;
  ::std::string* stf_class_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static ResourceSpawnClass* default_instance_;
};
// -------------------------------------------------------------------

class FactoryCrateItem : public ::google::protobuf::Message {
 public:
  FactoryCrateItem();
  virtual ~FactoryCrateItem();

  FactoryCrateItem(const FactoryCrateItem& from);

  inline FactoryCrateItem& operator=(const FactoryCrateItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FactoryCrateItem& default_instance();

  void Swap(FactoryCrateItem* other);

  // implements Message ----------------------------------------------

  FactoryCrateItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FactoryCrateItem& from);
  void MergeFrom(const FactoryCrateItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // required int32 max_items = 2;
  inline bool has_max_items() const;
  inline void clear_max_items();
  static const int kMaxItemsFieldNumber = 2;
  inline ::google::protobuf::int32 max_items() const;
  inline void set_max_items(::google::protobuf::int32 value);

  // required .swgemurpcserver.rpc.CharacterInventoryItem contained_items = 3;
  inline bool has_contained_items() const;
  inline void clear_contained_items();
  static const int kContainedItemsFieldNumber = 3;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& contained_items() const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_contained_items();
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* release_contained_items();
  inline void set_allocated_contained_items(::swgemurpcserver::rpc::CharacterInventoryItem* contained_items);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.FactoryCrateItem)
 private:
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_max_items();
  inline void clear_has_max_items();
  inline void set_has_contained_items();
  inline void clear_has_contained_items();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 max_items_;
  ::swgemurpcserver::rpc::CharacterInventoryItem* contained_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static FactoryCrateItem* default_instance_;
};
// -------------------------------------------------------------------

class PharmaceuticalItem : public ::google::protobuf::Message {
 public:
  PharmaceuticalItem();
  virtual ~PharmaceuticalItem();

  PharmaceuticalItem(const PharmaceuticalItem& from);

  inline PharmaceuticalItem& operator=(const PharmaceuticalItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PharmaceuticalItem& default_instance();

  void Swap(PharmaceuticalItem* other);

  // implements Message ----------------------------------------------

  PharmaceuticalItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PharmaceuticalItem& from);
  void MergeFrom(const PharmaceuticalItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PharmaceuticalItem_PharmaceuticalItemType PharmaceuticalItemType;
  static const PharmaceuticalItemType UNKNOWN = PharmaceuticalItem_PharmaceuticalItemType_UNKNOWN;
  static const PharmaceuticalItemType CUREPACK = PharmaceuticalItem_PharmaceuticalItemType_CUREPACK;
  static const PharmaceuticalItemType DOTPACK = PharmaceuticalItem_PharmaceuticalItemType_DOTPACK;
  static const PharmaceuticalItemType ENHANCEPACK = PharmaceuticalItem_PharmaceuticalItemType_ENHANCEPACK;
  static const PharmaceuticalItemType RANGEDSTIMPACK = PharmaceuticalItem_PharmaceuticalItemType_RANGEDSTIMPACK;
  static const PharmaceuticalItemType REVIVIEPACK = PharmaceuticalItem_PharmaceuticalItemType_REVIVIEPACK;
  static const PharmaceuticalItemType STIMPACK = PharmaceuticalItem_PharmaceuticalItemType_STIMPACK;
  static const PharmaceuticalItemType WOUNDPACK = PharmaceuticalItem_PharmaceuticalItemType_WOUNDPACK;
  static inline bool PharmaceuticalItemType_IsValid(int value) {
    return PharmaceuticalItem_PharmaceuticalItemType_IsValid(value);
  }
  static const PharmaceuticalItemType PharmaceuticalItemType_MIN =
    PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_MIN;
  static const PharmaceuticalItemType PharmaceuticalItemType_MAX =
    PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_MAX;
  static const int PharmaceuticalItemType_ARRAYSIZE =
    PharmaceuticalItem_PharmaceuticalItemType_PharmaceuticalItemType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PharmaceuticalItemType_descriptor() {
    return PharmaceuticalItem_PharmaceuticalItemType_descriptor();
  }
  static inline const ::std::string& PharmaceuticalItemType_Name(PharmaceuticalItemType value) {
    return PharmaceuticalItem_PharmaceuticalItemType_Name(value);
  }
  static inline bool PharmaceuticalItemType_Parse(const ::std::string& name,
      PharmaceuticalItemType* value) {
    return PharmaceuticalItem_PharmaceuticalItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .swgemurpcserver.rpc.PharmaceuticalItem.PharmaceuticalItemType pharma_type = 1;
  inline bool has_pharma_type() const;
  inline void clear_pharma_type();
  static const int kPharmaTypeFieldNumber = 1;
  inline ::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType pharma_type() const;
  inline void set_pharma_type(::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType value);

  // required float effectiveness = 2;
  inline bool has_effectiveness() const;
  inline void clear_effectiveness();
  static const int kEffectivenessFieldNumber = 2;
  inline float effectiveness() const;
  inline void set_effectiveness(float value);

  // required float area = 3;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 3;
  inline float area() const;
  inline void set_area(float value);

  // required int32 medicine_required = 4;
  inline bool has_medicine_required() const;
  inline void clear_medicine_required();
  static const int kMedicineRequiredFieldNumber = 4;
  inline ::google::protobuf::int32 medicine_required() const;
  inline void set_medicine_required(::google::protobuf::int32 value);

  // required int32 use_count = 5;
  inline bool has_use_count() const;
  inline void clear_use_count();
  static const int kUseCountFieldNumber = 5;
  inline ::google::protobuf::int32 use_count() const;
  inline void set_use_count(::google::protobuf::int32 value);

  // optional .swgemurpcserver.rpc.RangedStimPackItem ranged_stim_details = 6;
  inline bool has_ranged_stim_details() const;
  inline void clear_ranged_stim_details();
  static const int kRangedStimDetailsFieldNumber = 6;
  inline const ::swgemurpcserver::rpc::RangedStimPackItem& ranged_stim_details() const;
  inline ::swgemurpcserver::rpc::RangedStimPackItem* mutable_ranged_stim_details();
  inline ::swgemurpcserver::rpc::RangedStimPackItem* release_ranged_stim_details();
  inline void set_allocated_ranged_stim_details(::swgemurpcserver::rpc::RangedStimPackItem* ranged_stim_details);

  // optional .swgemurpcserver.rpc.DotPackItem dot_pack_details = 7;
  inline bool has_dot_pack_details() const;
  inline void clear_dot_pack_details();
  static const int kDotPackDetailsFieldNumber = 7;
  inline const ::swgemurpcserver::rpc::DotPackItem& dot_pack_details() const;
  inline ::swgemurpcserver::rpc::DotPackItem* mutable_dot_pack_details();
  inline ::swgemurpcserver::rpc::DotPackItem* release_dot_pack_details();
  inline void set_allocated_dot_pack_details(::swgemurpcserver::rpc::DotPackItem* dot_pack_details);

  // optional .swgemurpcserver.rpc.EnhancePackItem enhance_pack_details = 8;
  inline bool has_enhance_pack_details() const;
  inline void clear_enhance_pack_details();
  static const int kEnhancePackDetailsFieldNumber = 8;
  inline const ::swgemurpcserver::rpc::EnhancePackItem& enhance_pack_details() const;
  inline ::swgemurpcserver::rpc::EnhancePackItem* mutable_enhance_pack_details();
  inline ::swgemurpcserver::rpc::EnhancePackItem* release_enhance_pack_details();
  inline void set_allocated_enhance_pack_details(::swgemurpcserver::rpc::EnhancePackItem* enhance_pack_details);

  // optional .swgemurpcserver.rpc.RevivePackItem revivie_pack_details = 9;
  inline bool has_revivie_pack_details() const;
  inline void clear_revivie_pack_details();
  static const int kReviviePackDetailsFieldNumber = 9;
  inline const ::swgemurpcserver::rpc::RevivePackItem& revivie_pack_details() const;
  inline ::swgemurpcserver::rpc::RevivePackItem* mutable_revivie_pack_details();
  inline ::swgemurpcserver::rpc::RevivePackItem* release_revivie_pack_details();
  inline void set_allocated_revivie_pack_details(::swgemurpcserver::rpc::RevivePackItem* revivie_pack_details);

  // optional .swgemurpcserver.rpc.WoundPackItem wound_pack_details = 10;
  inline bool has_wound_pack_details() const;
  inline void clear_wound_pack_details();
  static const int kWoundPackDetailsFieldNumber = 10;
  inline const ::swgemurpcserver::rpc::WoundPackItem& wound_pack_details() const;
  inline ::swgemurpcserver::rpc::WoundPackItem* mutable_wound_pack_details();
  inline ::swgemurpcserver::rpc::WoundPackItem* release_wound_pack_details();
  inline void set_allocated_wound_pack_details(::swgemurpcserver::rpc::WoundPackItem* wound_pack_details);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.PharmaceuticalItem)
 private:
  inline void set_has_pharma_type();
  inline void clear_has_pharma_type();
  inline void set_has_effectiveness();
  inline void clear_has_effectiveness();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_medicine_required();
  inline void clear_has_medicine_required();
  inline void set_has_use_count();
  inline void clear_has_use_count();
  inline void set_has_ranged_stim_details();
  inline void clear_has_ranged_stim_details();
  inline void set_has_dot_pack_details();
  inline void clear_has_dot_pack_details();
  inline void set_has_enhance_pack_details();
  inline void clear_has_enhance_pack_details();
  inline void set_has_revivie_pack_details();
  inline void clear_has_revivie_pack_details();
  inline void set_has_wound_pack_details();
  inline void clear_has_wound_pack_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int pharma_type_;
  float effectiveness_;
  float area_;
  ::google::protobuf::int32 medicine_required_;
  ::swgemurpcserver::rpc::RangedStimPackItem* ranged_stim_details_;
  ::swgemurpcserver::rpc::DotPackItem* dot_pack_details_;
  ::swgemurpcserver::rpc::EnhancePackItem* enhance_pack_details_;
  ::swgemurpcserver::rpc::RevivePackItem* revivie_pack_details_;
  ::swgemurpcserver::rpc::WoundPackItem* wound_pack_details_;
  ::google::protobuf::int32 use_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static PharmaceuticalItem* default_instance_;
};
// -------------------------------------------------------------------

class RangedStimPackItem : public ::google::protobuf::Message {
 public:
  RangedStimPackItem();
  virtual ~RangedStimPackItem();

  RangedStimPackItem(const RangedStimPackItem& from);

  inline RangedStimPackItem& operator=(const RangedStimPackItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RangedStimPackItem& default_instance();

  void Swap(RangedStimPackItem* other);

  // implements Message ----------------------------------------------

  RangedStimPackItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RangedStimPackItem& from);
  void MergeFrom(const RangedStimPackItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float range_mod = 1;
  inline bool has_range_mod() const;
  inline void clear_range_mod();
  static const int kRangeModFieldNumber = 1;
  inline float range_mod() const;
  inline void set_range_mod(float value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.RangedStimPackItem)
 private:
  inline void set_has_range_mod();
  inline void clear_has_range_mod();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float range_mod_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static RangedStimPackItem* default_instance_;
};
// -------------------------------------------------------------------

class DotPackItem : public ::google::protobuf::Message {
 public:
  DotPackItem();
  virtual ~DotPackItem();

  DotPackItem(const DotPackItem& from);

  inline DotPackItem& operator=(const DotPackItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DotPackItem& default_instance();

  void Swap(DotPackItem* other);

  // implements Message ----------------------------------------------

  DotPackItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DotPackItem& from);
  void MergeFrom(const DotPackItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float potency = 1;
  inline bool has_potency() const;
  inline void clear_potency();
  static const int kPotencyFieldNumber = 1;
  inline float potency() const;
  inline void set_potency(float value);

  // required fixed32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // required string pool = 3;
  inline bool has_pool() const;
  inline void clear_pool();
  static const int kPoolFieldNumber = 3;
  inline const ::std::string& pool() const;
  inline void set_pool(const ::std::string& value);
  inline void set_pool(const char* value);
  inline void set_pool(const char* value, size_t size);
  inline ::std::string* mutable_pool();
  inline ::std::string* release_pool();
  inline void set_allocated_pool(::std::string* pool);

  // required fixed32 dot_type = 4;
  inline bool has_dot_type() const;
  inline void clear_dot_type();
  static const int kDotTypeFieldNumber = 4;
  inline ::google::protobuf::uint32 dot_type() const;
  inline void set_dot_type(::google::protobuf::uint32 value);

  // required bool poison_unit = 5;
  inline bool has_poison_unit() const;
  inline void clear_poison_unit();
  static const int kPoisonUnitFieldNumber = 5;
  inline bool poison_unit() const;
  inline void set_poison_unit(bool value);

  // required bool disease_unit = 6;
  inline bool has_disease_unit() const;
  inline void clear_disease_unit();
  static const int kDiseaseUnitFieldNumber = 6;
  inline bool disease_unit() const;
  inline void set_disease_unit(bool value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.DotPackItem)
 private:
  inline void set_has_potency();
  inline void clear_has_potency();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_pool();
  inline void clear_has_pool();
  inline void set_has_dot_type();
  inline void clear_has_dot_type();
  inline void set_has_poison_unit();
  inline void clear_has_poison_unit();
  inline void set_has_disease_unit();
  inline void clear_has_disease_unit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float potency_;
  ::google::protobuf::uint32 duration_;
  ::std::string* pool_;
  ::google::protobuf::uint32 dot_type_;
  bool poison_unit_;
  bool disease_unit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static DotPackItem* default_instance_;
};
// -------------------------------------------------------------------

class EnhancePackItem : public ::google::protobuf::Message {
 public:
  EnhancePackItem();
  virtual ~EnhancePackItem();

  EnhancePackItem(const EnhancePackItem& from);

  inline EnhancePackItem& operator=(const EnhancePackItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EnhancePackItem& default_instance();

  void Swap(EnhancePackItem* other);

  // implements Message ----------------------------------------------

  EnhancePackItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EnhancePackItem& from);
  void MergeFrom(const EnhancePackItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float duration = 1;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 1;
  inline float duration() const;
  inline void set_duration(float value);

  // required string attribute = 2;
  inline bool has_attribute() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 2;
  inline const ::std::string& attribute() const;
  inline void set_attribute(const ::std::string& value);
  inline void set_attribute(const char* value);
  inline void set_attribute(const char* value, size_t size);
  inline ::std::string* mutable_attribute();
  inline ::std::string* release_attribute();
  inline void set_allocated_attribute(::std::string* attribute);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.EnhancePackItem)
 private:
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_attribute();
  inline void clear_has_attribute();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* attribute_;
  float duration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static EnhancePackItem* default_instance_;
};
// -------------------------------------------------------------------

class RevivePackItem : public ::google::protobuf::Message {
 public:
  RevivePackItem();
  virtual ~RevivePackItem();

  RevivePackItem(const RevivePackItem& from);

  inline RevivePackItem& operator=(const RevivePackItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RevivePackItem& default_instance();

  void Swap(RevivePackItem* other);

  // implements Message ----------------------------------------------

  RevivePackItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RevivePackItem& from);
  void MergeFrom(const RevivePackItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float health_wound_healed = 1;
  inline bool has_health_wound_healed() const;
  inline void clear_health_wound_healed();
  static const int kHealthWoundHealedFieldNumber = 1;
  inline float health_wound_healed() const;
  inline void set_health_wound_healed(float value);

  // required float health_healed = 2;
  inline bool has_health_healed() const;
  inline void clear_health_healed();
  static const int kHealthHealedFieldNumber = 2;
  inline float health_healed() const;
  inline void set_health_healed(float value);

  // required float action_wound_healed = 3;
  inline bool has_action_wound_healed() const;
  inline void clear_action_wound_healed();
  static const int kActionWoundHealedFieldNumber = 3;
  inline float action_wound_healed() const;
  inline void set_action_wound_healed(float value);

  // required float action_healed = 4;
  inline bool has_action_healed() const;
  inline void clear_action_healed();
  static const int kActionHealedFieldNumber = 4;
  inline float action_healed() const;
  inline void set_action_healed(float value);

  // required float mind_wound_healed = 5;
  inline bool has_mind_wound_healed() const;
  inline void clear_mind_wound_healed();
  static const int kMindWoundHealedFieldNumber = 5;
  inline float mind_wound_healed() const;
  inline void set_mind_wound_healed(float value);

  // required float mind_healed = 6;
  inline bool has_mind_healed() const;
  inline void clear_mind_healed();
  static const int kMindHealedFieldNumber = 6;
  inline float mind_healed() const;
  inline void set_mind_healed(float value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.RevivePackItem)
 private:
  inline void set_has_health_wound_healed();
  inline void clear_has_health_wound_healed();
  inline void set_has_health_healed();
  inline void clear_has_health_healed();
  inline void set_has_action_wound_healed();
  inline void clear_has_action_wound_healed();
  inline void set_has_action_healed();
  inline void clear_has_action_healed();
  inline void set_has_mind_wound_healed();
  inline void clear_has_mind_wound_healed();
  inline void set_has_mind_healed();
  inline void clear_has_mind_healed();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float health_wound_healed_;
  float health_healed_;
  float action_wound_healed_;
  float action_healed_;
  float mind_wound_healed_;
  float mind_healed_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static RevivePackItem* default_instance_;
};
// -------------------------------------------------------------------

class WoundPackItem : public ::google::protobuf::Message {
 public:
  WoundPackItem();
  virtual ~WoundPackItem();

  WoundPackItem(const WoundPackItem& from);

  inline WoundPackItem& operator=(const WoundPackItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WoundPackItem& default_instance();

  void Swap(WoundPackItem* other);

  // implements Message ----------------------------------------------

  WoundPackItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WoundPackItem& from);
  void MergeFrom(const WoundPackItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string attribute = 1;
  inline bool has_attribute() const;
  inline void clear_attribute();
  static const int kAttributeFieldNumber = 1;
  inline const ::std::string& attribute() const;
  inline void set_attribute(const ::std::string& value);
  inline void set_attribute(const char* value);
  inline void set_attribute(const char* value, size_t size);
  inline ::std::string* mutable_attribute();
  inline ::std::string* release_attribute();
  inline void set_allocated_attribute(::std::string* attribute);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.WoundPackItem)
 private:
  inline void set_has_attribute();
  inline void clear_has_attribute();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* attribute_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static WoundPackItem* default_instance_;
};
// -------------------------------------------------------------------

class CraftingComponentItem : public ::google::protobuf::Message {
 public:
  CraftingComponentItem();
  virtual ~CraftingComponentItem();

  CraftingComponentItem(const CraftingComponentItem& from);

  inline CraftingComponentItem& operator=(const CraftingComponentItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CraftingComponentItem& default_instance();

  void Swap(CraftingComponentItem* other);

  // implements Message ----------------------------------------------

  CraftingComponentItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CraftingComponentItem& from);
  void MergeFrom(const CraftingComponentItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .swgemurpcserver.rpc.CraftingComponentAttribute attributes = 1;
  inline int attributes_size() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 1;
  inline const ::swgemurpcserver::rpc::CraftingComponentAttribute& attributes(int index) const;
  inline ::swgemurpcserver::rpc::CraftingComponentAttribute* mutable_attributes(int index);
  inline ::swgemurpcserver::rpc::CraftingComponentAttribute* add_attributes();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CraftingComponentAttribute >&
      attributes() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CraftingComponentAttribute >*
      mutable_attributes();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.CraftingComponentItem)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CraftingComponentAttribute > attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static CraftingComponentItem* default_instance_;
};
// -------------------------------------------------------------------

class CraftingComponentAttribute : public ::google::protobuf::Message {
 public:
  CraftingComponentAttribute();
  virtual ~CraftingComponentAttribute();

  CraftingComponentAttribute(const CraftingComponentAttribute& from);

  inline CraftingComponentAttribute& operator=(const CraftingComponentAttribute& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CraftingComponentAttribute& default_instance();

  void Swap(CraftingComponentAttribute* other);

  // implements Message ----------------------------------------------

  CraftingComponentAttribute* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CraftingComponentAttribute& from);
  void MergeFrom(const CraftingComponentAttribute& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required string tite = 2;
  inline bool has_tite() const;
  inline void clear_tite();
  static const int kTiteFieldNumber = 2;
  inline const ::std::string& tite() const;
  inline void set_tite(const ::std::string& value);
  inline void set_tite(const char* value);
  inline void set_tite(const char* value, size_t size);
  inline ::std::string* mutable_tite();
  inline ::std::string* release_tite();
  inline void set_allocated_tite(::std::string* tite);

  // required int32 precision = 3;
  inline bool has_precision() const;
  inline void clear_precision();
  static const int kPrecisionFieldNumber = 3;
  inline ::google::protobuf::int32 precision() const;
  inline void set_precision(::google::protobuf::int32 value);

  // required float value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline float value() const;
  inline void set_value(float value);

  // required bool hidden = 5;
  inline bool has_hidden() const;
  inline void clear_hidden();
  static const int kHiddenFieldNumber = 5;
  inline bool hidden() const;
  inline void set_hidden(bool value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.CraftingComponentAttribute)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_tite();
  inline void clear_has_tite();
  inline void set_has_precision();
  inline void clear_has_precision();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_hidden();
  inline void clear_has_hidden();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* tite_;
  ::google::protobuf::int32 precision_;
  float value_;
  bool hidden_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static CraftingComponentAttribute* default_instance_;
};
// -------------------------------------------------------------------

class ManufacturingSchematicItem : public ::google::protobuf::Message {
 public:
  ManufacturingSchematicItem();
  virtual ~ManufacturingSchematicItem();

  ManufacturingSchematicItem(const ManufacturingSchematicItem& from);

  inline ManufacturingSchematicItem& operator=(const ManufacturingSchematicItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ManufacturingSchematicItem& default_instance();

  void Swap(ManufacturingSchematicItem* other);

  // implements Message ----------------------------------------------

  ManufacturingSchematicItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ManufacturingSchematicItem& from);
  void MergeFrom(const ManufacturingSchematicItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 manufacture_limit = 1;
  inline bool has_manufacture_limit() const;
  inline void clear_manufacture_limit();
  static const int kManufactureLimitFieldNumber = 1;
  inline ::google::protobuf::int32 manufacture_limit() const;
  inline void set_manufacture_limit(::google::protobuf::int32 value);

  // required .swgemurpcserver.rpc.CharacterInventoryItem prototype_details = 2;
  inline bool has_prototype_details() const;
  inline void clear_prototype_details();
  static const int kPrototypeDetailsFieldNumber = 2;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& prototype_details() const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_prototype_details();
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* release_prototype_details();
  inline void set_allocated_prototype_details(::swgemurpcserver::rpc::CharacterInventoryItem* prototype_details);

  // repeated .swgemurpcserver.rpc.BlueprintEntryItem blueprint_entries = 3;
  inline int blueprint_entries_size() const;
  inline void clear_blueprint_entries();
  static const int kBlueprintEntriesFieldNumber = 3;
  inline const ::swgemurpcserver::rpc::BlueprintEntryItem& blueprint_entries(int index) const;
  inline ::swgemurpcserver::rpc::BlueprintEntryItem* mutable_blueprint_entries(int index);
  inline ::swgemurpcserver::rpc::BlueprintEntryItem* add_blueprint_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::BlueprintEntryItem >&
      blueprint_entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::BlueprintEntryItem >*
      mutable_blueprint_entries();

  // repeated .swgemurpcserver.rpc.IngredientItem ingredients = 4;
  inline int ingredients_size() const;
  inline void clear_ingredients();
  static const int kIngredientsFieldNumber = 4;
  inline const ::swgemurpcserver::rpc::IngredientItem& ingredients(int index) const;
  inline ::swgemurpcserver::rpc::IngredientItem* mutable_ingredients(int index);
  inline ::swgemurpcserver::rpc::IngredientItem* add_ingredients();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::IngredientItem >&
      ingredients() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::IngredientItem >*
      mutable_ingredients();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.ManufacturingSchematicItem)
 private:
  inline void set_has_manufacture_limit();
  inline void clear_has_manufacture_limit();
  inline void set_has_prototype_details();
  inline void clear_has_prototype_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::swgemurpcserver::rpc::CharacterInventoryItem* prototype_details_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::BlueprintEntryItem > blueprint_entries_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::IngredientItem > ingredients_;
  ::google::protobuf::int32 manufacture_limit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static ManufacturingSchematicItem* default_instance_;
};
// -------------------------------------------------------------------

class IngredientItem : public ::google::protobuf::Message {
 public:
  IngredientItem();
  virtual ~IngredientItem();

  IngredientItem(const IngredientItem& from);

  inline IngredientItem& operator=(const IngredientItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IngredientItem& default_instance();

  void Swap(IngredientItem* other);

  // implements Message ----------------------------------------------

  IngredientItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IngredientItem& from);
  void MergeFrom(const IngredientItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 required_quantity = 1;
  inline bool has_required_quantity() const;
  inline void clear_required_quantity();
  static const int kRequiredQuantityFieldNumber = 1;
  inline ::google::protobuf::int32 required_quantity() const;
  inline void set_required_quantity(::google::protobuf::int32 value);

  // required bool identical = 2;
  inline bool has_identical() const;
  inline void clear_identical();
  static const int kIdenticalFieldNumber = 2;
  inline bool identical() const;
  inline void set_identical(bool value);

  // required string ingredient_slot_name = 3;
  inline bool has_ingredient_slot_name() const;
  inline void clear_ingredient_slot_name();
  static const int kIngredientSlotNameFieldNumber = 3;
  inline const ::std::string& ingredient_slot_name() const;
  inline void set_ingredient_slot_name(const ::std::string& value);
  inline void set_ingredient_slot_name(const char* value);
  inline void set_ingredient_slot_name(const char* value, size_t size);
  inline ::std::string* mutable_ingredient_slot_name();
  inline ::std::string* release_ingredient_slot_name();
  inline void set_allocated_ingredient_slot_name(::std::string* ingredient_slot_name);

  // required .swgemurpcserver.rpc.CharacterInventoryItem ingredient = 4;
  inline bool has_ingredient() const;
  inline void clear_ingredient();
  static const int kIngredientFieldNumber = 4;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& ingredient() const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_ingredient();
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* release_ingredient();
  inline void set_allocated_ingredient(::swgemurpcserver::rpc::CharacterInventoryItem* ingredient);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.IngredientItem)
 private:
  inline void set_has_required_quantity();
  inline void clear_has_required_quantity();
  inline void set_has_identical();
  inline void clear_has_identical();
  inline void set_has_ingredient_slot_name();
  inline void clear_has_ingredient_slot_name();
  inline void set_has_ingredient();
  inline void clear_has_ingredient();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 required_quantity_;
  bool identical_;
  ::std::string* ingredient_slot_name_;
  ::swgemurpcserver::rpc::CharacterInventoryItem* ingredient_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static IngredientItem* default_instance_;
};
// -------------------------------------------------------------------

class BlueprintEntryItem : public ::google::protobuf::Message {
 public:
  BlueprintEntryItem();
  virtual ~BlueprintEntryItem();

  BlueprintEntryItem(const BlueprintEntryItem& from);

  inline BlueprintEntryItem& operator=(const BlueprintEntryItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlueprintEntryItem& default_instance();

  void Swap(BlueprintEntryItem* other);

  // implements Message ----------------------------------------------

  BlueprintEntryItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BlueprintEntryItem& from);
  void MergeFrom(const BlueprintEntryItem& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string serial = 3;
  inline bool has_serial() const;
  inline void clear_serial();
  static const int kSerialFieldNumber = 3;
  inline const ::std::string& serial() const;
  inline void set_serial(const ::std::string& value);
  inline void set_serial(const char* value);
  inline void set_serial(const char* value, size_t size);
  inline ::std::string* mutable_serial();
  inline ::std::string* release_serial();
  inline void set_allocated_serial(::std::string* serial);

  // required string display_name = 4;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // required int32 quantity = 5;
  inline bool has_quantity() const;
  inline void clear_quantity();
  static const int kQuantityFieldNumber = 5;
  inline ::google::protobuf::int32 quantity() const;
  inline void set_quantity(::google::protobuf::int32 value);

  // required bool identical = 6;
  inline bool has_identical() const;
  inline void clear_identical();
  static const int kIdenticalFieldNumber = 6;
  inline bool identical() const;
  inline void set_identical(bool value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.BlueprintEntryItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_serial();
  inline void clear_has_serial();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_quantity();
  inline void clear_has_quantity();
  inline void set_has_identical();
  inline void clear_has_identical();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* type_;
  ::std::string* key_;
  ::std::string* serial_;
  ::std::string* display_name_;
  ::google::protobuf::int32 quantity_;
  bool identical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_InventoryItem_2eproto();
  friend void protobuf_AssignDesc_InventoryItem_2eproto();
  friend void protobuf_ShutdownFile_InventoryItem_2eproto();

  void InitAsDefaultInstance();
  static BlueprintEntryItem* default_instance_;
};
// ===================================================================


// ===================================================================

// CharacterInventoryItem

// required fixed64 object_id = 1;
inline bool CharacterInventoryItem::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CharacterInventoryItem::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CharacterInventoryItem::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CharacterInventoryItem::clear_object_id() {
  object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_id();
}
inline ::google::protobuf::uint64 CharacterInventoryItem::object_id() const {
  return object_id_;
}
inline void CharacterInventoryItem::set_object_id(::google::protobuf::uint64 value) {
  set_has_object_id();
  object_id_ = value;
}

// required string appearance_file_name = 2;
inline bool CharacterInventoryItem::has_appearance_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CharacterInventoryItem::set_has_appearance_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CharacterInventoryItem::clear_has_appearance_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CharacterInventoryItem::clear_appearance_file_name() {
  if (appearance_file_name_ != &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_->clear();
  }
  clear_has_appearance_file_name();
}
inline const ::std::string& CharacterInventoryItem::appearance_file_name() const {
  return *appearance_file_name_;
}
inline void CharacterInventoryItem::set_appearance_file_name(const ::std::string& value) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_appearance_file_name(const char* value) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_appearance_file_name(const char* value, size_t size) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_appearance_file_name() {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  return appearance_file_name_;
}
inline ::std::string* CharacterInventoryItem::release_appearance_file_name() {
  clear_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appearance_file_name_;
    appearance_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_appearance_file_name(::std::string* appearance_file_name) {
  if (appearance_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete appearance_file_name_;
  }
  if (appearance_file_name) {
    set_has_appearance_file_name();
    appearance_file_name_ = appearance_file_name;
  } else {
    clear_has_appearance_file_name();
    appearance_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string object_name = 3;
inline bool CharacterInventoryItem::has_object_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CharacterInventoryItem::set_has_object_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CharacterInventoryItem::clear_has_object_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CharacterInventoryItem::clear_object_name() {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    object_name_->clear();
  }
  clear_has_object_name();
}
inline const ::std::string& CharacterInventoryItem::object_name() const {
  return *object_name_;
}
inline void CharacterInventoryItem::set_object_name(const ::std::string& value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void CharacterInventoryItem::set_object_name(const char* value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void CharacterInventoryItem::set_object_name(const char* value, size_t size) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_object_name() {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  return object_name_;
}
inline ::std::string* CharacterInventoryItem::release_object_name() {
  clear_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_name_;
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_object_name(::std::string* object_name) {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    delete object_name_;
  }
  if (object_name) {
    set_has_object_name();
    object_name_ = object_name;
  } else {
    clear_has_object_name();
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string display_name = 4;
inline bool CharacterInventoryItem::has_display_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CharacterInventoryItem::set_has_display_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CharacterInventoryItem::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CharacterInventoryItem::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& CharacterInventoryItem::display_name() const {
  return *display_name_;
}
inline void CharacterInventoryItem::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void CharacterInventoryItem::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void CharacterInventoryItem::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* CharacterInventoryItem::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string description = 5;
inline bool CharacterInventoryItem::has_description() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CharacterInventoryItem::set_has_description() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CharacterInventoryItem::clear_has_description() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CharacterInventoryItem::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& CharacterInventoryItem::description() const {
  return *description_;
}
inline void CharacterInventoryItem::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CharacterInventoryItem::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void CharacterInventoryItem::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* CharacterInventoryItem::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string crafter_name = 6;
inline bool CharacterInventoryItem::has_crafter_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CharacterInventoryItem::set_has_crafter_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CharacterInventoryItem::clear_has_crafter_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CharacterInventoryItem::clear_crafter_name() {
  if (crafter_name_ != &::google::protobuf::internal::kEmptyString) {
    crafter_name_->clear();
  }
  clear_has_crafter_name();
}
inline const ::std::string& CharacterInventoryItem::crafter_name() const {
  return *crafter_name_;
}
inline void CharacterInventoryItem::set_crafter_name(const ::std::string& value) {
  set_has_crafter_name();
  if (crafter_name_ == &::google::protobuf::internal::kEmptyString) {
    crafter_name_ = new ::std::string;
  }
  crafter_name_->assign(value);
}
inline void CharacterInventoryItem::set_crafter_name(const char* value) {
  set_has_crafter_name();
  if (crafter_name_ == &::google::protobuf::internal::kEmptyString) {
    crafter_name_ = new ::std::string;
  }
  crafter_name_->assign(value);
}
inline void CharacterInventoryItem::set_crafter_name(const char* value, size_t size) {
  set_has_crafter_name();
  if (crafter_name_ == &::google::protobuf::internal::kEmptyString) {
    crafter_name_ = new ::std::string;
  }
  crafter_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_crafter_name() {
  set_has_crafter_name();
  if (crafter_name_ == &::google::protobuf::internal::kEmptyString) {
    crafter_name_ = new ::std::string;
  }
  return crafter_name_;
}
inline ::std::string* CharacterInventoryItem::release_crafter_name() {
  clear_has_crafter_name();
  if (crafter_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = crafter_name_;
    crafter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_crafter_name(::std::string* crafter_name) {
  if (crafter_name_ != &::google::protobuf::internal::kEmptyString) {
    delete crafter_name_;
  }
  if (crafter_name) {
    set_has_crafter_name();
    crafter_name_ = crafter_name;
  } else {
    clear_has_crafter_name();
    crafter_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string serial_number = 7;
inline bool CharacterInventoryItem::has_serial_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CharacterInventoryItem::set_has_serial_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CharacterInventoryItem::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CharacterInventoryItem::clear_serial_number() {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    serial_number_->clear();
  }
  clear_has_serial_number();
}
inline const ::std::string& CharacterInventoryItem::serial_number() const {
  return *serial_number_;
}
inline void CharacterInventoryItem::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void CharacterInventoryItem::set_serial_number(const char* value) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(value);
}
inline void CharacterInventoryItem::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  serial_number_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_serial_number() {
  set_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    serial_number_ = new ::std::string;
  }
  return serial_number_;
}
inline ::std::string* CharacterInventoryItem::release_serial_number() {
  clear_has_serial_number();
  if (serial_number_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_number_;
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_number_;
  }
  if (serial_number) {
    set_has_serial_number();
    serial_number_ = serial_number;
  } else {
    clear_has_serial_number();
    serial_number_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 max_condition = 8;
inline bool CharacterInventoryItem::has_max_condition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CharacterInventoryItem::set_has_max_condition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CharacterInventoryItem::clear_has_max_condition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CharacterInventoryItem::clear_max_condition() {
  max_condition_ = 0;
  clear_has_max_condition();
}
inline ::google::protobuf::int32 CharacterInventoryItem::max_condition() const {
  return max_condition_;
}
inline void CharacterInventoryItem::set_max_condition(::google::protobuf::int32 value) {
  set_has_max_condition();
  max_condition_ = value;
}

// optional int32 condition = 9;
inline bool CharacterInventoryItem::has_condition() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CharacterInventoryItem::set_has_condition() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CharacterInventoryItem::clear_has_condition() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CharacterInventoryItem::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline ::google::protobuf::int32 CharacterInventoryItem::condition() const {
  return condition_;
}
inline void CharacterInventoryItem::set_condition(::google::protobuf::int32 value) {
  set_has_condition();
  condition_ = value;
}

// optional fixed32 containment_location = 10;
inline bool CharacterInventoryItem::has_containment_location() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CharacterInventoryItem::set_has_containment_location() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CharacterInventoryItem::clear_has_containment_location() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CharacterInventoryItem::clear_containment_location() {
  containment_location_ = 0u;
  clear_has_containment_location();
}
inline ::google::protobuf::uint32 CharacterInventoryItem::containment_location() const {
  return containment_location_;
}
inline void CharacterInventoryItem::set_containment_location(::google::protobuf::uint32 value) {
  set_has_containment_location();
  containment_location_ = value;
}

// optional string template_file_name = 11;
inline bool CharacterInventoryItem::has_template_file_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CharacterInventoryItem::set_has_template_file_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CharacterInventoryItem::clear_has_template_file_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CharacterInventoryItem::clear_template_file_name() {
  if (template_file_name_ != &::google::protobuf::internal::kEmptyString) {
    template_file_name_->clear();
  }
  clear_has_template_file_name();
}
inline const ::std::string& CharacterInventoryItem::template_file_name() const {
  return *template_file_name_;
}
inline void CharacterInventoryItem::set_template_file_name(const ::std::string& value) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_template_file_name(const char* value) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_template_file_name(const char* value, size_t size) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_template_file_name() {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  return template_file_name_;
}
inline ::std::string* CharacterInventoryItem::release_template_file_name() {
  clear_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = template_file_name_;
    template_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_template_file_name(::std::string* template_file_name) {
  if (template_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete template_file_name_;
  }
  if (template_file_name) {
    set_has_template_file_name();
    template_file_name_ = template_file_name;
  } else {
    clear_has_template_file_name();
    template_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portals_file_name = 12;
inline bool CharacterInventoryItem::has_portals_file_name() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CharacterInventoryItem::set_has_portals_file_name() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CharacterInventoryItem::clear_has_portals_file_name() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CharacterInventoryItem::clear_portals_file_name() {
  if (portals_file_name_ != &::google::protobuf::internal::kEmptyString) {
    portals_file_name_->clear();
  }
  clear_has_portals_file_name();
}
inline const ::std::string& CharacterInventoryItem::portals_file_name() const {
  return *portals_file_name_;
}
inline void CharacterInventoryItem::set_portals_file_name(const ::std::string& value) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_portals_file_name(const char* value) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(value);
}
inline void CharacterInventoryItem::set_portals_file_name(const char* value, size_t size) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CharacterInventoryItem::mutable_portals_file_name() {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  return portals_file_name_;
}
inline ::std::string* CharacterInventoryItem::release_portals_file_name() {
  clear_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portals_file_name_;
    portals_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CharacterInventoryItem::set_allocated_portals_file_name(::std::string* portals_file_name) {
  if (portals_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete portals_file_name_;
  }
  if (portals_file_name) {
    set_has_portals_file_name();
    portals_file_name_ = portals_file_name;
  } else {
    clear_has_portals_file_name();
    portals_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .swgemurpcserver.rpc.ArmorItem armor_details = 13;
inline bool CharacterInventoryItem::has_armor_details() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CharacterInventoryItem::set_has_armor_details() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CharacterInventoryItem::clear_has_armor_details() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CharacterInventoryItem::clear_armor_details() {
  if (armor_details_ != NULL) armor_details_->::swgemurpcserver::rpc::ArmorItem::Clear();
  clear_has_armor_details();
}
inline const ::swgemurpcserver::rpc::ArmorItem& CharacterInventoryItem::armor_details() const {
  return armor_details_ != NULL ? *armor_details_ : *default_instance_->armor_details_;
}
inline ::swgemurpcserver::rpc::ArmorItem* CharacterInventoryItem::mutable_armor_details() {
  set_has_armor_details();
  if (armor_details_ == NULL) armor_details_ = new ::swgemurpcserver::rpc::ArmorItem;
  return armor_details_;
}
inline ::swgemurpcserver::rpc::ArmorItem* CharacterInventoryItem::release_armor_details() {
  clear_has_armor_details();
  ::swgemurpcserver::rpc::ArmorItem* temp = armor_details_;
  armor_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_armor_details(::swgemurpcserver::rpc::ArmorItem* armor_details) {
  delete armor_details_;
  armor_details_ = armor_details;
  if (armor_details) {
    set_has_armor_details();
  } else {
    clear_has_armor_details();
  }
}

// optional .swgemurpcserver.rpc.WeaponItem weapon_details = 14;
inline bool CharacterInventoryItem::has_weapon_details() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CharacterInventoryItem::set_has_weapon_details() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CharacterInventoryItem::clear_has_weapon_details() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CharacterInventoryItem::clear_weapon_details() {
  if (weapon_details_ != NULL) weapon_details_->::swgemurpcserver::rpc::WeaponItem::Clear();
  clear_has_weapon_details();
}
inline const ::swgemurpcserver::rpc::WeaponItem& CharacterInventoryItem::weapon_details() const {
  return weapon_details_ != NULL ? *weapon_details_ : *default_instance_->weapon_details_;
}
inline ::swgemurpcserver::rpc::WeaponItem* CharacterInventoryItem::mutable_weapon_details() {
  set_has_weapon_details();
  if (weapon_details_ == NULL) weapon_details_ = new ::swgemurpcserver::rpc::WeaponItem;
  return weapon_details_;
}
inline ::swgemurpcserver::rpc::WeaponItem* CharacterInventoryItem::release_weapon_details() {
  clear_has_weapon_details();
  ::swgemurpcserver::rpc::WeaponItem* temp = weapon_details_;
  weapon_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_weapon_details(::swgemurpcserver::rpc::WeaponItem* weapon_details) {
  delete weapon_details_;
  weapon_details_ = weapon_details;
  if (weapon_details) {
    set_has_weapon_details();
  } else {
    clear_has_weapon_details();
  }
}

// optional .swgemurpcserver.rpc.ResourceContainerItem resource_details = 15;
inline bool CharacterInventoryItem::has_resource_details() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void CharacterInventoryItem::set_has_resource_details() {
  _has_bits_[0] |= 0x00004000u;
}
inline void CharacterInventoryItem::clear_has_resource_details() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void CharacterInventoryItem::clear_resource_details() {
  if (resource_details_ != NULL) resource_details_->::swgemurpcserver::rpc::ResourceContainerItem::Clear();
  clear_has_resource_details();
}
inline const ::swgemurpcserver::rpc::ResourceContainerItem& CharacterInventoryItem::resource_details() const {
  return resource_details_ != NULL ? *resource_details_ : *default_instance_->resource_details_;
}
inline ::swgemurpcserver::rpc::ResourceContainerItem* CharacterInventoryItem::mutable_resource_details() {
  set_has_resource_details();
  if (resource_details_ == NULL) resource_details_ = new ::swgemurpcserver::rpc::ResourceContainerItem;
  return resource_details_;
}
inline ::swgemurpcserver::rpc::ResourceContainerItem* CharacterInventoryItem::release_resource_details() {
  clear_has_resource_details();
  ::swgemurpcserver::rpc::ResourceContainerItem* temp = resource_details_;
  resource_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_resource_details(::swgemurpcserver::rpc::ResourceContainerItem* resource_details) {
  delete resource_details_;
  resource_details_ = resource_details;
  if (resource_details) {
    set_has_resource_details();
  } else {
    clear_has_resource_details();
  }
}

// optional .swgemurpcserver.rpc.FactoryCrateItem factory_crate_details = 16;
inline bool CharacterInventoryItem::has_factory_crate_details() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void CharacterInventoryItem::set_has_factory_crate_details() {
  _has_bits_[0] |= 0x00008000u;
}
inline void CharacterInventoryItem::clear_has_factory_crate_details() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void CharacterInventoryItem::clear_factory_crate_details() {
  if (factory_crate_details_ != NULL) factory_crate_details_->::swgemurpcserver::rpc::FactoryCrateItem::Clear();
  clear_has_factory_crate_details();
}
inline const ::swgemurpcserver::rpc::FactoryCrateItem& CharacterInventoryItem::factory_crate_details() const {
  return factory_crate_details_ != NULL ? *factory_crate_details_ : *default_instance_->factory_crate_details_;
}
inline ::swgemurpcserver::rpc::FactoryCrateItem* CharacterInventoryItem::mutable_factory_crate_details() {
  set_has_factory_crate_details();
  if (factory_crate_details_ == NULL) factory_crate_details_ = new ::swgemurpcserver::rpc::FactoryCrateItem;
  return factory_crate_details_;
}
inline ::swgemurpcserver::rpc::FactoryCrateItem* CharacterInventoryItem::release_factory_crate_details() {
  clear_has_factory_crate_details();
  ::swgemurpcserver::rpc::FactoryCrateItem* temp = factory_crate_details_;
  factory_crate_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_factory_crate_details(::swgemurpcserver::rpc::FactoryCrateItem* factory_crate_details) {
  delete factory_crate_details_;
  factory_crate_details_ = factory_crate_details;
  if (factory_crate_details) {
    set_has_factory_crate_details();
  } else {
    clear_has_factory_crate_details();
  }
}

// optional .swgemurpcserver.rpc.PharmaceuticalItem pharmaceutical_details = 17;
inline bool CharacterInventoryItem::has_pharmaceutical_details() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void CharacterInventoryItem::set_has_pharmaceutical_details() {
  _has_bits_[0] |= 0x00010000u;
}
inline void CharacterInventoryItem::clear_has_pharmaceutical_details() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void CharacterInventoryItem::clear_pharmaceutical_details() {
  if (pharmaceutical_details_ != NULL) pharmaceutical_details_->::swgemurpcserver::rpc::PharmaceuticalItem::Clear();
  clear_has_pharmaceutical_details();
}
inline const ::swgemurpcserver::rpc::PharmaceuticalItem& CharacterInventoryItem::pharmaceutical_details() const {
  return pharmaceutical_details_ != NULL ? *pharmaceutical_details_ : *default_instance_->pharmaceutical_details_;
}
inline ::swgemurpcserver::rpc::PharmaceuticalItem* CharacterInventoryItem::mutable_pharmaceutical_details() {
  set_has_pharmaceutical_details();
  if (pharmaceutical_details_ == NULL) pharmaceutical_details_ = new ::swgemurpcserver::rpc::PharmaceuticalItem;
  return pharmaceutical_details_;
}
inline ::swgemurpcserver::rpc::PharmaceuticalItem* CharacterInventoryItem::release_pharmaceutical_details() {
  clear_has_pharmaceutical_details();
  ::swgemurpcserver::rpc::PharmaceuticalItem* temp = pharmaceutical_details_;
  pharmaceutical_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_pharmaceutical_details(::swgemurpcserver::rpc::PharmaceuticalItem* pharmaceutical_details) {
  delete pharmaceutical_details_;
  pharmaceutical_details_ = pharmaceutical_details;
  if (pharmaceutical_details) {
    set_has_pharmaceutical_details();
  } else {
    clear_has_pharmaceutical_details();
  }
}

// optional .swgemurpcserver.rpc.CraftingComponentItem crafting_component_details = 18;
inline bool CharacterInventoryItem::has_crafting_component_details() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void CharacterInventoryItem::set_has_crafting_component_details() {
  _has_bits_[0] |= 0x00020000u;
}
inline void CharacterInventoryItem::clear_has_crafting_component_details() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void CharacterInventoryItem::clear_crafting_component_details() {
  if (crafting_component_details_ != NULL) crafting_component_details_->::swgemurpcserver::rpc::CraftingComponentItem::Clear();
  clear_has_crafting_component_details();
}
inline const ::swgemurpcserver::rpc::CraftingComponentItem& CharacterInventoryItem::crafting_component_details() const {
  return crafting_component_details_ != NULL ? *crafting_component_details_ : *default_instance_->crafting_component_details_;
}
inline ::swgemurpcserver::rpc::CraftingComponentItem* CharacterInventoryItem::mutable_crafting_component_details() {
  set_has_crafting_component_details();
  if (crafting_component_details_ == NULL) crafting_component_details_ = new ::swgemurpcserver::rpc::CraftingComponentItem;
  return crafting_component_details_;
}
inline ::swgemurpcserver::rpc::CraftingComponentItem* CharacterInventoryItem::release_crafting_component_details() {
  clear_has_crafting_component_details();
  ::swgemurpcserver::rpc::CraftingComponentItem* temp = crafting_component_details_;
  crafting_component_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_crafting_component_details(::swgemurpcserver::rpc::CraftingComponentItem* crafting_component_details) {
  delete crafting_component_details_;
  crafting_component_details_ = crafting_component_details;
  if (crafting_component_details) {
    set_has_crafting_component_details();
  } else {
    clear_has_crafting_component_details();
  }
}

// optional .swgemurpcserver.rpc.ManufacturingSchematicItem mfg_schem_details = 19;
inline bool CharacterInventoryItem::has_mfg_schem_details() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void CharacterInventoryItem::set_has_mfg_schem_details() {
  _has_bits_[0] |= 0x00040000u;
}
inline void CharacterInventoryItem::clear_has_mfg_schem_details() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void CharacterInventoryItem::clear_mfg_schem_details() {
  if (mfg_schem_details_ != NULL) mfg_schem_details_->::swgemurpcserver::rpc::ManufacturingSchematicItem::Clear();
  clear_has_mfg_schem_details();
}
inline const ::swgemurpcserver::rpc::ManufacturingSchematicItem& CharacterInventoryItem::mfg_schem_details() const {
  return mfg_schem_details_ != NULL ? *mfg_schem_details_ : *default_instance_->mfg_schem_details_;
}
inline ::swgemurpcserver::rpc::ManufacturingSchematicItem* CharacterInventoryItem::mutable_mfg_schem_details() {
  set_has_mfg_schem_details();
  if (mfg_schem_details_ == NULL) mfg_schem_details_ = new ::swgemurpcserver::rpc::ManufacturingSchematicItem;
  return mfg_schem_details_;
}
inline ::swgemurpcserver::rpc::ManufacturingSchematicItem* CharacterInventoryItem::release_mfg_schem_details() {
  clear_has_mfg_schem_details();
  ::swgemurpcserver::rpc::ManufacturingSchematicItem* temp = mfg_schem_details_;
  mfg_schem_details_ = NULL;
  return temp;
}
inline void CharacterInventoryItem::set_allocated_mfg_schem_details(::swgemurpcserver::rpc::ManufacturingSchematicItem* mfg_schem_details) {
  delete mfg_schem_details_;
  mfg_schem_details_ = mfg_schem_details;
  if (mfg_schem_details) {
    set_has_mfg_schem_details();
  } else {
    clear_has_mfg_schem_details();
  }
}

// -------------------------------------------------------------------

// ArmorItem

// required float kinetic = 1;
inline bool ArmorItem::has_kinetic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArmorItem::set_has_kinetic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArmorItem::clear_has_kinetic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArmorItem::clear_kinetic() {
  kinetic_ = 0;
  clear_has_kinetic();
}
inline float ArmorItem::kinetic() const {
  return kinetic_;
}
inline void ArmorItem::set_kinetic(float value) {
  set_has_kinetic();
  kinetic_ = value;
}

// required float energy = 2;
inline bool ArmorItem::has_energy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArmorItem::set_has_energy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArmorItem::clear_has_energy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArmorItem::clear_energy() {
  energy_ = 0;
  clear_has_energy();
}
inline float ArmorItem::energy() const {
  return energy_;
}
inline void ArmorItem::set_energy(float value) {
  set_has_energy();
  energy_ = value;
}

// required float electricity = 3;
inline bool ArmorItem::has_electricity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArmorItem::set_has_electricity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArmorItem::clear_has_electricity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArmorItem::clear_electricity() {
  electricity_ = 0;
  clear_has_electricity();
}
inline float ArmorItem::electricity() const {
  return electricity_;
}
inline void ArmorItem::set_electricity(float value) {
  set_has_electricity();
  electricity_ = value;
}

// required float stun = 4;
inline bool ArmorItem::has_stun() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArmorItem::set_has_stun() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArmorItem::clear_has_stun() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArmorItem::clear_stun() {
  stun_ = 0;
  clear_has_stun();
}
inline float ArmorItem::stun() const {
  return stun_;
}
inline void ArmorItem::set_stun(float value) {
  set_has_stun();
  stun_ = value;
}

// required float blast = 5;
inline bool ArmorItem::has_blast() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArmorItem::set_has_blast() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArmorItem::clear_has_blast() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArmorItem::clear_blast() {
  blast_ = 0;
  clear_has_blast();
}
inline float ArmorItem::blast() const {
  return blast_;
}
inline void ArmorItem::set_blast(float value) {
  set_has_blast();
  blast_ = value;
}

// required float heat = 6;
inline bool ArmorItem::has_heat() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArmorItem::set_has_heat() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArmorItem::clear_has_heat() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArmorItem::clear_heat() {
  heat_ = 0;
  clear_has_heat();
}
inline float ArmorItem::heat() const {
  return heat_;
}
inline void ArmorItem::set_heat(float value) {
  set_has_heat();
  heat_ = value;
}

// required float cold = 7;
inline bool ArmorItem::has_cold() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArmorItem::set_has_cold() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArmorItem::clear_has_cold() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArmorItem::clear_cold() {
  cold_ = 0;
  clear_has_cold();
}
inline float ArmorItem::cold() const {
  return cold_;
}
inline void ArmorItem::set_cold(float value) {
  set_has_cold();
  cold_ = value;
}

// required float acid = 8;
inline bool ArmorItem::has_acid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArmorItem::set_has_acid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArmorItem::clear_has_acid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArmorItem::clear_acid() {
  acid_ = 0;
  clear_has_acid();
}
inline float ArmorItem::acid() const {
  return acid_;
}
inline void ArmorItem::set_acid(float value) {
  set_has_acid();
  acid_ = value;
}

// required float lighsaber = 9;
inline bool ArmorItem::has_lighsaber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArmorItem::set_has_lighsaber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArmorItem::clear_has_lighsaber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArmorItem::clear_lighsaber() {
  lighsaber_ = 0;
  clear_has_lighsaber();
}
inline float ArmorItem::lighsaber() const {
  return lighsaber_;
}
inline void ArmorItem::set_lighsaber(float value) {
  set_has_lighsaber();
  lighsaber_ = value;
}

// required int32 health_encumberance = 10;
inline bool ArmorItem::has_health_encumberance() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ArmorItem::set_has_health_encumberance() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ArmorItem::clear_has_health_encumberance() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ArmorItem::clear_health_encumberance() {
  health_encumberance_ = 0;
  clear_has_health_encumberance();
}
inline ::google::protobuf::int32 ArmorItem::health_encumberance() const {
  return health_encumberance_;
}
inline void ArmorItem::set_health_encumberance(::google::protobuf::int32 value) {
  set_has_health_encumberance();
  health_encumberance_ = value;
}

// required int32 action_encumberance = 11;
inline bool ArmorItem::has_action_encumberance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ArmorItem::set_has_action_encumberance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ArmorItem::clear_has_action_encumberance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ArmorItem::clear_action_encumberance() {
  action_encumberance_ = 0;
  clear_has_action_encumberance();
}
inline ::google::protobuf::int32 ArmorItem::action_encumberance() const {
  return action_encumberance_;
}
inline void ArmorItem::set_action_encumberance(::google::protobuf::int32 value) {
  set_has_action_encumberance();
  action_encumberance_ = value;
}

// required int32 mind_encumberance = 12;
inline bool ArmorItem::has_mind_encumberance() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ArmorItem::set_has_mind_encumberance() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ArmorItem::clear_has_mind_encumberance() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ArmorItem::clear_mind_encumberance() {
  mind_encumberance_ = 0;
  clear_has_mind_encumberance();
}
inline ::google::protobuf::int32 ArmorItem::mind_encumberance() const {
  return mind_encumberance_;
}
inline void ArmorItem::set_mind_encumberance(::google::protobuf::int32 value) {
  set_has_mind_encumberance();
  mind_encumberance_ = value;
}

// required int32 rating = 13;
inline bool ArmorItem::has_rating() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ArmorItem::set_has_rating() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ArmorItem::clear_has_rating() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ArmorItem::clear_rating() {
  rating_ = 0;
  clear_has_rating();
}
inline ::google::protobuf::int32 ArmorItem::rating() const {
  return rating_;
}
inline void ArmorItem::set_rating(::google::protobuf::int32 value) {
  set_has_rating();
  rating_ = value;
}

// repeated int32 hit_location = 14 [packed = true];
inline int ArmorItem::hit_location_size() const {
  return hit_location_.size();
}
inline void ArmorItem::clear_hit_location() {
  hit_location_.Clear();
}
inline ::google::protobuf::int32 ArmorItem::hit_location(int index) const {
  return hit_location_.Get(index);
}
inline void ArmorItem::set_hit_location(int index, ::google::protobuf::int32 value) {
  hit_location_.Set(index, value);
}
inline void ArmorItem::add_hit_location(::google::protobuf::int32 value) {
  hit_location_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ArmorItem::hit_location() const {
  return hit_location_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ArmorItem::mutable_hit_location() {
  return &hit_location_;
}

// -------------------------------------------------------------------

// WeaponItem

// required int32 point_blank_accuracy = 1;
inline bool WeaponItem::has_point_blank_accuracy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeaponItem::set_has_point_blank_accuracy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeaponItem::clear_has_point_blank_accuracy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeaponItem::clear_point_blank_accuracy() {
  point_blank_accuracy_ = 0;
  clear_has_point_blank_accuracy();
}
inline ::google::protobuf::int32 WeaponItem::point_blank_accuracy() const {
  return point_blank_accuracy_;
}
inline void WeaponItem::set_point_blank_accuracy(::google::protobuf::int32 value) {
  set_has_point_blank_accuracy();
  point_blank_accuracy_ = value;
}

// required int32 point_blank_range = 2;
inline bool WeaponItem::has_point_blank_range() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeaponItem::set_has_point_blank_range() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeaponItem::clear_has_point_blank_range() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeaponItem::clear_point_blank_range() {
  point_blank_range_ = 0;
  clear_has_point_blank_range();
}
inline ::google::protobuf::int32 WeaponItem::point_blank_range() const {
  return point_blank_range_;
}
inline void WeaponItem::set_point_blank_range(::google::protobuf::int32 value) {
  set_has_point_blank_range();
  point_blank_range_ = value;
}

// required int32 ideal_range = 3;
inline bool WeaponItem::has_ideal_range() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeaponItem::set_has_ideal_range() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeaponItem::clear_has_ideal_range() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeaponItem::clear_ideal_range() {
  ideal_range_ = 0;
  clear_has_ideal_range();
}
inline ::google::protobuf::int32 WeaponItem::ideal_range() const {
  return ideal_range_;
}
inline void WeaponItem::set_ideal_range(::google::protobuf::int32 value) {
  set_has_ideal_range();
  ideal_range_ = value;
}

// required int32 max_range = 4;
inline bool WeaponItem::has_max_range() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeaponItem::set_has_max_range() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeaponItem::clear_has_max_range() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeaponItem::clear_max_range() {
  max_range_ = 0;
  clear_has_max_range();
}
inline ::google::protobuf::int32 WeaponItem::max_range() const {
  return max_range_;
}
inline void WeaponItem::set_max_range(::google::protobuf::int32 value) {
  set_has_max_range();
  max_range_ = value;
}

// required int32 ideal_accuracy = 5;
inline bool WeaponItem::has_ideal_accuracy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeaponItem::set_has_ideal_accuracy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeaponItem::clear_has_ideal_accuracy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeaponItem::clear_ideal_accuracy() {
  ideal_accuracy_ = 0;
  clear_has_ideal_accuracy();
}
inline ::google::protobuf::int32 WeaponItem::ideal_accuracy() const {
  return ideal_accuracy_;
}
inline void WeaponItem::set_ideal_accuracy(::google::protobuf::int32 value) {
  set_has_ideal_accuracy();
  ideal_accuracy_ = value;
}

// required int32 max_range_accuracy = 6;
inline bool WeaponItem::has_max_range_accuracy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WeaponItem::set_has_max_range_accuracy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WeaponItem::clear_has_max_range_accuracy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WeaponItem::clear_max_range_accuracy() {
  max_range_accuracy_ = 0;
  clear_has_max_range_accuracy();
}
inline ::google::protobuf::int32 WeaponItem::max_range_accuracy() const {
  return max_range_accuracy_;
}
inline void WeaponItem::set_max_range_accuracy(::google::protobuf::int32 value) {
  set_has_max_range_accuracy();
  max_range_accuracy_ = value;
}

// required int32 armor_piercing = 7;
inline bool WeaponItem::has_armor_piercing() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WeaponItem::set_has_armor_piercing() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WeaponItem::clear_has_armor_piercing() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WeaponItem::clear_armor_piercing() {
  armor_piercing_ = 0;
  clear_has_armor_piercing();
}
inline ::google::protobuf::int32 WeaponItem::armor_piercing() const {
  return armor_piercing_;
}
inline void WeaponItem::set_armor_piercing(::google::protobuf::int32 value) {
  set_has_armor_piercing();
  armor_piercing_ = value;
}

// required float attack_speed = 8;
inline bool WeaponItem::has_attack_speed() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WeaponItem::set_has_attack_speed() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WeaponItem::clear_has_attack_speed() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WeaponItem::clear_attack_speed() {
  attack_speed_ = 0;
  clear_has_attack_speed();
}
inline float WeaponItem::attack_speed() const {
  return attack_speed_;
}
inline void WeaponItem::set_attack_speed(float value) {
  set_has_attack_speed();
  attack_speed_ = value;
}

// required float max_damage = 9;
inline bool WeaponItem::has_max_damage() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WeaponItem::set_has_max_damage() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WeaponItem::clear_has_max_damage() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WeaponItem::clear_max_damage() {
  max_damage_ = 0;
  clear_has_max_damage();
}
inline float WeaponItem::max_damage() const {
  return max_damage_;
}
inline void WeaponItem::set_max_damage(float value) {
  set_has_max_damage();
  max_damage_ = value;
}

// required float min_damage = 10;
inline bool WeaponItem::has_min_damage() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WeaponItem::set_has_min_damage() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WeaponItem::clear_has_min_damage() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WeaponItem::clear_min_damage() {
  min_damage_ = 0;
  clear_has_min_damage();
}
inline float WeaponItem::min_damage() const {
  return min_damage_;
}
inline void WeaponItem::set_min_damage(float value) {
  set_has_min_damage();
  min_damage_ = value;
}

// required float wound_ratio = 11;
inline bool WeaponItem::has_wound_ratio() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WeaponItem::set_has_wound_ratio() {
  _has_bits_[0] |= 0x00000400u;
}
inline void WeaponItem::clear_has_wound_ratio() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void WeaponItem::clear_wound_ratio() {
  wound_ratio_ = 0;
  clear_has_wound_ratio();
}
inline float WeaponItem::wound_ratio() const {
  return wound_ratio_;
}
inline void WeaponItem::set_wound_ratio(float value) {
  set_has_wound_ratio();
  wound_ratio_ = value;
}

// required float damage_radius = 12;
inline bool WeaponItem::has_damage_radius() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void WeaponItem::set_has_damage_radius() {
  _has_bits_[0] |= 0x00000800u;
}
inline void WeaponItem::clear_has_damage_radius() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void WeaponItem::clear_damage_radius() {
  damage_radius_ = 0;
  clear_has_damage_radius();
}
inline float WeaponItem::damage_radius() const {
  return damage_radius_;
}
inline void WeaponItem::set_damage_radius(float value) {
  set_has_damage_radius();
  damage_radius_ = value;
}

// required int32 health_attack_cost = 13;
inline bool WeaponItem::has_health_attack_cost() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void WeaponItem::set_has_health_attack_cost() {
  _has_bits_[0] |= 0x00001000u;
}
inline void WeaponItem::clear_has_health_attack_cost() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void WeaponItem::clear_health_attack_cost() {
  health_attack_cost_ = 0;
  clear_has_health_attack_cost();
}
inline ::google::protobuf::int32 WeaponItem::health_attack_cost() const {
  return health_attack_cost_;
}
inline void WeaponItem::set_health_attack_cost(::google::protobuf::int32 value) {
  set_has_health_attack_cost();
  health_attack_cost_ = value;
}

// required int32 action_attack_cost = 14;
inline bool WeaponItem::has_action_attack_cost() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void WeaponItem::set_has_action_attack_cost() {
  _has_bits_[0] |= 0x00002000u;
}
inline void WeaponItem::clear_has_action_attack_cost() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void WeaponItem::clear_action_attack_cost() {
  action_attack_cost_ = 0;
  clear_has_action_attack_cost();
}
inline ::google::protobuf::int32 WeaponItem::action_attack_cost() const {
  return action_attack_cost_;
}
inline void WeaponItem::set_action_attack_cost(::google::protobuf::int32 value) {
  set_has_action_attack_cost();
  action_attack_cost_ = value;
}

// required int32 mind_attack_cost = 15;
inline bool WeaponItem::has_mind_attack_cost() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void WeaponItem::set_has_mind_attack_cost() {
  _has_bits_[0] |= 0x00004000u;
}
inline void WeaponItem::clear_has_mind_attack_cost() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void WeaponItem::clear_mind_attack_cost() {
  mind_attack_cost_ = 0;
  clear_has_mind_attack_cost();
}
inline ::google::protobuf::int32 WeaponItem::mind_attack_cost() const {
  return mind_attack_cost_;
}
inline void WeaponItem::set_mind_attack_cost(::google::protobuf::int32 value) {
  set_has_mind_attack_cost();
  mind_attack_cost_ = value;
}

// required int32 force_attack_cost = 16;
inline bool WeaponItem::has_force_attack_cost() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void WeaponItem::set_has_force_attack_cost() {
  _has_bits_[0] |= 0x00008000u;
}
inline void WeaponItem::clear_has_force_attack_cost() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void WeaponItem::clear_force_attack_cost() {
  force_attack_cost_ = 0;
  clear_has_force_attack_cost();
}
inline ::google::protobuf::int32 WeaponItem::force_attack_cost() const {
  return force_attack_cost_;
}
inline void WeaponItem::set_force_attack_cost(::google::protobuf::int32 value) {
  set_has_force_attack_cost();
  force_attack_cost_ = value;
}

// required int32 damage_type = 17;
inline bool WeaponItem::has_damage_type() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void WeaponItem::set_has_damage_type() {
  _has_bits_[0] |= 0x00010000u;
}
inline void WeaponItem::clear_has_damage_type() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void WeaponItem::clear_damage_type() {
  damage_type_ = 0;
  clear_has_damage_type();
}
inline ::google::protobuf::int32 WeaponItem::damage_type() const {
  return damage_type_;
}
inline void WeaponItem::set_damage_type(::google::protobuf::int32 value) {
  set_has_damage_type();
  damage_type_ = value;
}

// required string weapon_type = 18;
inline bool WeaponItem::has_weapon_type() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void WeaponItem::set_has_weapon_type() {
  _has_bits_[0] |= 0x00020000u;
}
inline void WeaponItem::clear_has_weapon_type() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void WeaponItem::clear_weapon_type() {
  if (weapon_type_ != &::google::protobuf::internal::kEmptyString) {
    weapon_type_->clear();
  }
  clear_has_weapon_type();
}
inline const ::std::string& WeaponItem::weapon_type() const {
  return *weapon_type_;
}
inline void WeaponItem::set_weapon_type(const ::std::string& value) {
  set_has_weapon_type();
  if (weapon_type_ == &::google::protobuf::internal::kEmptyString) {
    weapon_type_ = new ::std::string;
  }
  weapon_type_->assign(value);
}
inline void WeaponItem::set_weapon_type(const char* value) {
  set_has_weapon_type();
  if (weapon_type_ == &::google::protobuf::internal::kEmptyString) {
    weapon_type_ = new ::std::string;
  }
  weapon_type_->assign(value);
}
inline void WeaponItem::set_weapon_type(const char* value, size_t size) {
  set_has_weapon_type();
  if (weapon_type_ == &::google::protobuf::internal::kEmptyString) {
    weapon_type_ = new ::std::string;
  }
  weapon_type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeaponItem::mutable_weapon_type() {
  set_has_weapon_type();
  if (weapon_type_ == &::google::protobuf::internal::kEmptyString) {
    weapon_type_ = new ::std::string;
  }
  return weapon_type_;
}
inline ::std::string* WeaponItem::release_weapon_type() {
  clear_has_weapon_type();
  if (weapon_type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = weapon_type_;
    weapon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeaponItem::set_allocated_weapon_type(::std::string* weapon_type) {
  if (weapon_type_ != &::google::protobuf::internal::kEmptyString) {
    delete weapon_type_;
  }
  if (weapon_type) {
    set_has_weapon_type();
    weapon_type_ = weapon_type;
  } else {
    clear_has_weapon_type();
    weapon_type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResourceContainerItem

// required string name = 1;
inline bool ResourceContainerItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceContainerItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceContainerItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceContainerItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ResourceContainerItem::name() const {
  return *name_;
}
inline void ResourceContainerItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResourceContainerItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResourceContainerItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceContainerItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ResourceContainerItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceContainerItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string type = 2;
inline bool ResourceContainerItem::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceContainerItem::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceContainerItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceContainerItem::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ResourceContainerItem::type() const {
  return *type_;
}
inline void ResourceContainerItem::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ResourceContainerItem::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ResourceContainerItem::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceContainerItem::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ResourceContainerItem::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceContainerItem::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 resource_id = 3;
inline bool ResourceContainerItem::has_resource_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceContainerItem::set_has_resource_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceContainerItem::clear_has_resource_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceContainerItem::clear_resource_id() {
  resource_id_ = GOOGLE_ULONGLONG(0);
  clear_has_resource_id();
}
inline ::google::protobuf::uint64 ResourceContainerItem::resource_id() const {
  return resource_id_;
}
inline void ResourceContainerItem::set_resource_id(::google::protobuf::uint64 value) {
  set_has_resource_id();
  resource_id_ = value;
}

// required int32 count = 4;
inline bool ResourceContainerItem::has_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResourceContainerItem::set_has_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResourceContainerItem::clear_has_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResourceContainerItem::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ResourceContainerItem::count() const {
  return count_;
}
inline void ResourceContainerItem::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// repeated .swgemurpcserver.rpc.ResourceSpawnClass classes = 5;
inline int ResourceContainerItem::classes_size() const {
  return classes_.size();
}
inline void ResourceContainerItem::clear_classes() {
  classes_.Clear();
}
inline const ::swgemurpcserver::rpc::ResourceSpawnClass& ResourceContainerItem::classes(int index) const {
  return classes_.Get(index);
}
inline ::swgemurpcserver::rpc::ResourceSpawnClass* ResourceContainerItem::mutable_classes(int index) {
  return classes_.Mutable(index);
}
inline ::swgemurpcserver::rpc::ResourceSpawnClass* ResourceContainerItem::add_classes() {
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceSpawnClass >&
ResourceContainerItem::classes() const {
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceSpawnClass >*
ResourceContainerItem::mutable_classes() {
  return &classes_;
}

// repeated .swgemurpcserver.rpc.ResourceAttribute attributes = 6;
inline int ResourceContainerItem::attributes_size() const {
  return attributes_.size();
}
inline void ResourceContainerItem::clear_attributes() {
  attributes_.Clear();
}
inline const ::swgemurpcserver::rpc::ResourceAttribute& ResourceContainerItem::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::swgemurpcserver::rpc::ResourceAttribute* ResourceContainerItem::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::swgemurpcserver::rpc::ResourceAttribute* ResourceContainerItem::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceAttribute >&
ResourceContainerItem::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::ResourceAttribute >*
ResourceContainerItem::mutable_attributes() {
  return &attributes_;
}

// -------------------------------------------------------------------

// ResourceAttribute

// required string name = 1;
inline bool ResourceAttribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceAttribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceAttribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceAttribute::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ResourceAttribute::name() const {
  return *name_;
}
inline void ResourceAttribute::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResourceAttribute::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ResourceAttribute::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceAttribute::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ResourceAttribute::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceAttribute::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 value = 2;
inline bool ResourceAttribute::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceAttribute::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceAttribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceAttribute::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 ResourceAttribute::value() const {
  return value_;
}
inline void ResourceAttribute::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// ResourceSpawnClass

// required string class_name = 1;
inline bool ResourceSpawnClass::has_class_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceSpawnClass::set_has_class_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceSpawnClass::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceSpawnClass::clear_class_name() {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    class_name_->clear();
  }
  clear_has_class_name();
}
inline const ::std::string& ResourceSpawnClass::class_name() const {
  return *class_name_;
}
inline void ResourceSpawnClass::set_class_name(const ::std::string& value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void ResourceSpawnClass::set_class_name(const char* value) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(value);
}
inline void ResourceSpawnClass::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  class_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceSpawnClass::mutable_class_name() {
  set_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    class_name_ = new ::std::string;
  }
  return class_name_;
}
inline ::std::string* ResourceSpawnClass::release_class_name() {
  clear_has_class_name();
  if (class_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = class_name_;
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceSpawnClass::set_allocated_class_name(::std::string* class_name) {
  if (class_name_ != &::google::protobuf::internal::kEmptyString) {
    delete class_name_;
  }
  if (class_name) {
    set_has_class_name();
    class_name_ = class_name;
  } else {
    clear_has_class_name();
    class_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string stf_class = 2;
inline bool ResourceSpawnClass::has_stf_class() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceSpawnClass::set_has_stf_class() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceSpawnClass::clear_has_stf_class() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceSpawnClass::clear_stf_class() {
  if (stf_class_ != &::google::protobuf::internal::kEmptyString) {
    stf_class_->clear();
  }
  clear_has_stf_class();
}
inline const ::std::string& ResourceSpawnClass::stf_class() const {
  return *stf_class_;
}
inline void ResourceSpawnClass::set_stf_class(const ::std::string& value) {
  set_has_stf_class();
  if (stf_class_ == &::google::protobuf::internal::kEmptyString) {
    stf_class_ = new ::std::string;
  }
  stf_class_->assign(value);
}
inline void ResourceSpawnClass::set_stf_class(const char* value) {
  set_has_stf_class();
  if (stf_class_ == &::google::protobuf::internal::kEmptyString) {
    stf_class_ = new ::std::string;
  }
  stf_class_->assign(value);
}
inline void ResourceSpawnClass::set_stf_class(const char* value, size_t size) {
  set_has_stf_class();
  if (stf_class_ == &::google::protobuf::internal::kEmptyString) {
    stf_class_ = new ::std::string;
  }
  stf_class_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceSpawnClass::mutable_stf_class() {
  set_has_stf_class();
  if (stf_class_ == &::google::protobuf::internal::kEmptyString) {
    stf_class_ = new ::std::string;
  }
  return stf_class_;
}
inline ::std::string* ResourceSpawnClass::release_stf_class() {
  clear_has_stf_class();
  if (stf_class_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stf_class_;
    stf_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceSpawnClass::set_allocated_stf_class(::std::string* stf_class) {
  if (stf_class_ != &::google::protobuf::internal::kEmptyString) {
    delete stf_class_;
  }
  if (stf_class) {
    set_has_stf_class();
    stf_class_ = stf_class;
  } else {
    clear_has_stf_class();
    stf_class_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// FactoryCrateItem

// required int32 count = 1;
inline bool FactoryCrateItem::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FactoryCrateItem::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FactoryCrateItem::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FactoryCrateItem::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 FactoryCrateItem::count() const {
  return count_;
}
inline void FactoryCrateItem::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// required int32 max_items = 2;
inline bool FactoryCrateItem::has_max_items() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FactoryCrateItem::set_has_max_items() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FactoryCrateItem::clear_has_max_items() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FactoryCrateItem::clear_max_items() {
  max_items_ = 0;
  clear_has_max_items();
}
inline ::google::protobuf::int32 FactoryCrateItem::max_items() const {
  return max_items_;
}
inline void FactoryCrateItem::set_max_items(::google::protobuf::int32 value) {
  set_has_max_items();
  max_items_ = value;
}

// required .swgemurpcserver.rpc.CharacterInventoryItem contained_items = 3;
inline bool FactoryCrateItem::has_contained_items() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FactoryCrateItem::set_has_contained_items() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FactoryCrateItem::clear_has_contained_items() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FactoryCrateItem::clear_contained_items() {
  if (contained_items_ != NULL) contained_items_->::swgemurpcserver::rpc::CharacterInventoryItem::Clear();
  clear_has_contained_items();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& FactoryCrateItem::contained_items() const {
  return contained_items_ != NULL ? *contained_items_ : *default_instance_->contained_items_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryCrateItem::mutable_contained_items() {
  set_has_contained_items();
  if (contained_items_ == NULL) contained_items_ = new ::swgemurpcserver::rpc::CharacterInventoryItem;
  return contained_items_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryCrateItem::release_contained_items() {
  clear_has_contained_items();
  ::swgemurpcserver::rpc::CharacterInventoryItem* temp = contained_items_;
  contained_items_ = NULL;
  return temp;
}
inline void FactoryCrateItem::set_allocated_contained_items(::swgemurpcserver::rpc::CharacterInventoryItem* contained_items) {
  delete contained_items_;
  contained_items_ = contained_items;
  if (contained_items) {
    set_has_contained_items();
  } else {
    clear_has_contained_items();
  }
}

// -------------------------------------------------------------------

// PharmaceuticalItem

// required .swgemurpcserver.rpc.PharmaceuticalItem.PharmaceuticalItemType pharma_type = 1;
inline bool PharmaceuticalItem::has_pharma_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PharmaceuticalItem::set_has_pharma_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PharmaceuticalItem::clear_has_pharma_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PharmaceuticalItem::clear_pharma_type() {
  pharma_type_ = -1;
  clear_has_pharma_type();
}
inline ::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType PharmaceuticalItem::pharma_type() const {
  return static_cast< ::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType >(pharma_type_);
}
inline void PharmaceuticalItem::set_pharma_type(::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType value) {
  assert(::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType_IsValid(value));
  set_has_pharma_type();
  pharma_type_ = value;
}

// required float effectiveness = 2;
inline bool PharmaceuticalItem::has_effectiveness() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PharmaceuticalItem::set_has_effectiveness() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PharmaceuticalItem::clear_has_effectiveness() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PharmaceuticalItem::clear_effectiveness() {
  effectiveness_ = 0;
  clear_has_effectiveness();
}
inline float PharmaceuticalItem::effectiveness() const {
  return effectiveness_;
}
inline void PharmaceuticalItem::set_effectiveness(float value) {
  set_has_effectiveness();
  effectiveness_ = value;
}

// required float area = 3;
inline bool PharmaceuticalItem::has_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PharmaceuticalItem::set_has_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PharmaceuticalItem::clear_has_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PharmaceuticalItem::clear_area() {
  area_ = 0;
  clear_has_area();
}
inline float PharmaceuticalItem::area() const {
  return area_;
}
inline void PharmaceuticalItem::set_area(float value) {
  set_has_area();
  area_ = value;
}

// required int32 medicine_required = 4;
inline bool PharmaceuticalItem::has_medicine_required() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PharmaceuticalItem::set_has_medicine_required() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PharmaceuticalItem::clear_has_medicine_required() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PharmaceuticalItem::clear_medicine_required() {
  medicine_required_ = 0;
  clear_has_medicine_required();
}
inline ::google::protobuf::int32 PharmaceuticalItem::medicine_required() const {
  return medicine_required_;
}
inline void PharmaceuticalItem::set_medicine_required(::google::protobuf::int32 value) {
  set_has_medicine_required();
  medicine_required_ = value;
}

// required int32 use_count = 5;
inline bool PharmaceuticalItem::has_use_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PharmaceuticalItem::set_has_use_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PharmaceuticalItem::clear_has_use_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PharmaceuticalItem::clear_use_count() {
  use_count_ = 0;
  clear_has_use_count();
}
inline ::google::protobuf::int32 PharmaceuticalItem::use_count() const {
  return use_count_;
}
inline void PharmaceuticalItem::set_use_count(::google::protobuf::int32 value) {
  set_has_use_count();
  use_count_ = value;
}

// optional .swgemurpcserver.rpc.RangedStimPackItem ranged_stim_details = 6;
inline bool PharmaceuticalItem::has_ranged_stim_details() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PharmaceuticalItem::set_has_ranged_stim_details() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PharmaceuticalItem::clear_has_ranged_stim_details() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PharmaceuticalItem::clear_ranged_stim_details() {
  if (ranged_stim_details_ != NULL) ranged_stim_details_->::swgemurpcserver::rpc::RangedStimPackItem::Clear();
  clear_has_ranged_stim_details();
}
inline const ::swgemurpcserver::rpc::RangedStimPackItem& PharmaceuticalItem::ranged_stim_details() const {
  return ranged_stim_details_ != NULL ? *ranged_stim_details_ : *default_instance_->ranged_stim_details_;
}
inline ::swgemurpcserver::rpc::RangedStimPackItem* PharmaceuticalItem::mutable_ranged_stim_details() {
  set_has_ranged_stim_details();
  if (ranged_stim_details_ == NULL) ranged_stim_details_ = new ::swgemurpcserver::rpc::RangedStimPackItem;
  return ranged_stim_details_;
}
inline ::swgemurpcserver::rpc::RangedStimPackItem* PharmaceuticalItem::release_ranged_stim_details() {
  clear_has_ranged_stim_details();
  ::swgemurpcserver::rpc::RangedStimPackItem* temp = ranged_stim_details_;
  ranged_stim_details_ = NULL;
  return temp;
}
inline void PharmaceuticalItem::set_allocated_ranged_stim_details(::swgemurpcserver::rpc::RangedStimPackItem* ranged_stim_details) {
  delete ranged_stim_details_;
  ranged_stim_details_ = ranged_stim_details;
  if (ranged_stim_details) {
    set_has_ranged_stim_details();
  } else {
    clear_has_ranged_stim_details();
  }
}

// optional .swgemurpcserver.rpc.DotPackItem dot_pack_details = 7;
inline bool PharmaceuticalItem::has_dot_pack_details() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PharmaceuticalItem::set_has_dot_pack_details() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PharmaceuticalItem::clear_has_dot_pack_details() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PharmaceuticalItem::clear_dot_pack_details() {
  if (dot_pack_details_ != NULL) dot_pack_details_->::swgemurpcserver::rpc::DotPackItem::Clear();
  clear_has_dot_pack_details();
}
inline const ::swgemurpcserver::rpc::DotPackItem& PharmaceuticalItem::dot_pack_details() const {
  return dot_pack_details_ != NULL ? *dot_pack_details_ : *default_instance_->dot_pack_details_;
}
inline ::swgemurpcserver::rpc::DotPackItem* PharmaceuticalItem::mutable_dot_pack_details() {
  set_has_dot_pack_details();
  if (dot_pack_details_ == NULL) dot_pack_details_ = new ::swgemurpcserver::rpc::DotPackItem;
  return dot_pack_details_;
}
inline ::swgemurpcserver::rpc::DotPackItem* PharmaceuticalItem::release_dot_pack_details() {
  clear_has_dot_pack_details();
  ::swgemurpcserver::rpc::DotPackItem* temp = dot_pack_details_;
  dot_pack_details_ = NULL;
  return temp;
}
inline void PharmaceuticalItem::set_allocated_dot_pack_details(::swgemurpcserver::rpc::DotPackItem* dot_pack_details) {
  delete dot_pack_details_;
  dot_pack_details_ = dot_pack_details;
  if (dot_pack_details) {
    set_has_dot_pack_details();
  } else {
    clear_has_dot_pack_details();
  }
}

// optional .swgemurpcserver.rpc.EnhancePackItem enhance_pack_details = 8;
inline bool PharmaceuticalItem::has_enhance_pack_details() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PharmaceuticalItem::set_has_enhance_pack_details() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PharmaceuticalItem::clear_has_enhance_pack_details() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PharmaceuticalItem::clear_enhance_pack_details() {
  if (enhance_pack_details_ != NULL) enhance_pack_details_->::swgemurpcserver::rpc::EnhancePackItem::Clear();
  clear_has_enhance_pack_details();
}
inline const ::swgemurpcserver::rpc::EnhancePackItem& PharmaceuticalItem::enhance_pack_details() const {
  return enhance_pack_details_ != NULL ? *enhance_pack_details_ : *default_instance_->enhance_pack_details_;
}
inline ::swgemurpcserver::rpc::EnhancePackItem* PharmaceuticalItem::mutable_enhance_pack_details() {
  set_has_enhance_pack_details();
  if (enhance_pack_details_ == NULL) enhance_pack_details_ = new ::swgemurpcserver::rpc::EnhancePackItem;
  return enhance_pack_details_;
}
inline ::swgemurpcserver::rpc::EnhancePackItem* PharmaceuticalItem::release_enhance_pack_details() {
  clear_has_enhance_pack_details();
  ::swgemurpcserver::rpc::EnhancePackItem* temp = enhance_pack_details_;
  enhance_pack_details_ = NULL;
  return temp;
}
inline void PharmaceuticalItem::set_allocated_enhance_pack_details(::swgemurpcserver::rpc::EnhancePackItem* enhance_pack_details) {
  delete enhance_pack_details_;
  enhance_pack_details_ = enhance_pack_details;
  if (enhance_pack_details) {
    set_has_enhance_pack_details();
  } else {
    clear_has_enhance_pack_details();
  }
}

// optional .swgemurpcserver.rpc.RevivePackItem revivie_pack_details = 9;
inline bool PharmaceuticalItem::has_revivie_pack_details() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PharmaceuticalItem::set_has_revivie_pack_details() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PharmaceuticalItem::clear_has_revivie_pack_details() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PharmaceuticalItem::clear_revivie_pack_details() {
  if (revivie_pack_details_ != NULL) revivie_pack_details_->::swgemurpcserver::rpc::RevivePackItem::Clear();
  clear_has_revivie_pack_details();
}
inline const ::swgemurpcserver::rpc::RevivePackItem& PharmaceuticalItem::revivie_pack_details() const {
  return revivie_pack_details_ != NULL ? *revivie_pack_details_ : *default_instance_->revivie_pack_details_;
}
inline ::swgemurpcserver::rpc::RevivePackItem* PharmaceuticalItem::mutable_revivie_pack_details() {
  set_has_revivie_pack_details();
  if (revivie_pack_details_ == NULL) revivie_pack_details_ = new ::swgemurpcserver::rpc::RevivePackItem;
  return revivie_pack_details_;
}
inline ::swgemurpcserver::rpc::RevivePackItem* PharmaceuticalItem::release_revivie_pack_details() {
  clear_has_revivie_pack_details();
  ::swgemurpcserver::rpc::RevivePackItem* temp = revivie_pack_details_;
  revivie_pack_details_ = NULL;
  return temp;
}
inline void PharmaceuticalItem::set_allocated_revivie_pack_details(::swgemurpcserver::rpc::RevivePackItem* revivie_pack_details) {
  delete revivie_pack_details_;
  revivie_pack_details_ = revivie_pack_details;
  if (revivie_pack_details) {
    set_has_revivie_pack_details();
  } else {
    clear_has_revivie_pack_details();
  }
}

// optional .swgemurpcserver.rpc.WoundPackItem wound_pack_details = 10;
inline bool PharmaceuticalItem::has_wound_pack_details() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PharmaceuticalItem::set_has_wound_pack_details() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PharmaceuticalItem::clear_has_wound_pack_details() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PharmaceuticalItem::clear_wound_pack_details() {
  if (wound_pack_details_ != NULL) wound_pack_details_->::swgemurpcserver::rpc::WoundPackItem::Clear();
  clear_has_wound_pack_details();
}
inline const ::swgemurpcserver::rpc::WoundPackItem& PharmaceuticalItem::wound_pack_details() const {
  return wound_pack_details_ != NULL ? *wound_pack_details_ : *default_instance_->wound_pack_details_;
}
inline ::swgemurpcserver::rpc::WoundPackItem* PharmaceuticalItem::mutable_wound_pack_details() {
  set_has_wound_pack_details();
  if (wound_pack_details_ == NULL) wound_pack_details_ = new ::swgemurpcserver::rpc::WoundPackItem;
  return wound_pack_details_;
}
inline ::swgemurpcserver::rpc::WoundPackItem* PharmaceuticalItem::release_wound_pack_details() {
  clear_has_wound_pack_details();
  ::swgemurpcserver::rpc::WoundPackItem* temp = wound_pack_details_;
  wound_pack_details_ = NULL;
  return temp;
}
inline void PharmaceuticalItem::set_allocated_wound_pack_details(::swgemurpcserver::rpc::WoundPackItem* wound_pack_details) {
  delete wound_pack_details_;
  wound_pack_details_ = wound_pack_details;
  if (wound_pack_details) {
    set_has_wound_pack_details();
  } else {
    clear_has_wound_pack_details();
  }
}

// -------------------------------------------------------------------

// RangedStimPackItem

// required float range_mod = 1;
inline bool RangedStimPackItem::has_range_mod() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RangedStimPackItem::set_has_range_mod() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RangedStimPackItem::clear_has_range_mod() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RangedStimPackItem::clear_range_mod() {
  range_mod_ = 0;
  clear_has_range_mod();
}
inline float RangedStimPackItem::range_mod() const {
  return range_mod_;
}
inline void RangedStimPackItem::set_range_mod(float value) {
  set_has_range_mod();
  range_mod_ = value;
}

// -------------------------------------------------------------------

// DotPackItem

// required float potency = 1;
inline bool DotPackItem::has_potency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DotPackItem::set_has_potency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DotPackItem::clear_has_potency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DotPackItem::clear_potency() {
  potency_ = 0;
  clear_has_potency();
}
inline float DotPackItem::potency() const {
  return potency_;
}
inline void DotPackItem::set_potency(float value) {
  set_has_potency();
  potency_ = value;
}

// required fixed32 duration = 2;
inline bool DotPackItem::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DotPackItem::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DotPackItem::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DotPackItem::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 DotPackItem::duration() const {
  return duration_;
}
inline void DotPackItem::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// required string pool = 3;
inline bool DotPackItem::has_pool() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DotPackItem::set_has_pool() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DotPackItem::clear_has_pool() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DotPackItem::clear_pool() {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    pool_->clear();
  }
  clear_has_pool();
}
inline const ::std::string& DotPackItem::pool() const {
  return *pool_;
}
inline void DotPackItem::set_pool(const ::std::string& value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void DotPackItem::set_pool(const char* value) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(value);
}
inline void DotPackItem::set_pool(const char* value, size_t size) {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  pool_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DotPackItem::mutable_pool() {
  set_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    pool_ = new ::std::string;
  }
  return pool_;
}
inline ::std::string* DotPackItem::release_pool() {
  clear_has_pool();
  if (pool_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pool_;
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DotPackItem::set_allocated_pool(::std::string* pool) {
  if (pool_ != &::google::protobuf::internal::kEmptyString) {
    delete pool_;
  }
  if (pool) {
    set_has_pool();
    pool_ = pool;
  } else {
    clear_has_pool();
    pool_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 dot_type = 4;
inline bool DotPackItem::has_dot_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DotPackItem::set_has_dot_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DotPackItem::clear_has_dot_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DotPackItem::clear_dot_type() {
  dot_type_ = 0u;
  clear_has_dot_type();
}
inline ::google::protobuf::uint32 DotPackItem::dot_type() const {
  return dot_type_;
}
inline void DotPackItem::set_dot_type(::google::protobuf::uint32 value) {
  set_has_dot_type();
  dot_type_ = value;
}

// required bool poison_unit = 5;
inline bool DotPackItem::has_poison_unit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DotPackItem::set_has_poison_unit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DotPackItem::clear_has_poison_unit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DotPackItem::clear_poison_unit() {
  poison_unit_ = false;
  clear_has_poison_unit();
}
inline bool DotPackItem::poison_unit() const {
  return poison_unit_;
}
inline void DotPackItem::set_poison_unit(bool value) {
  set_has_poison_unit();
  poison_unit_ = value;
}

// required bool disease_unit = 6;
inline bool DotPackItem::has_disease_unit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DotPackItem::set_has_disease_unit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DotPackItem::clear_has_disease_unit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DotPackItem::clear_disease_unit() {
  disease_unit_ = false;
  clear_has_disease_unit();
}
inline bool DotPackItem::disease_unit() const {
  return disease_unit_;
}
inline void DotPackItem::set_disease_unit(bool value) {
  set_has_disease_unit();
  disease_unit_ = value;
}

// -------------------------------------------------------------------

// EnhancePackItem

// required float duration = 1;
inline bool EnhancePackItem::has_duration() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EnhancePackItem::set_has_duration() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EnhancePackItem::clear_has_duration() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EnhancePackItem::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float EnhancePackItem::duration() const {
  return duration_;
}
inline void EnhancePackItem::set_duration(float value) {
  set_has_duration();
  duration_ = value;
}

// required string attribute = 2;
inline bool EnhancePackItem::has_attribute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EnhancePackItem::set_has_attribute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EnhancePackItem::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EnhancePackItem::clear_attribute() {
  if (attribute_ != &::google::protobuf::internal::kEmptyString) {
    attribute_->clear();
  }
  clear_has_attribute();
}
inline const ::std::string& EnhancePackItem::attribute() const {
  return *attribute_;
}
inline void EnhancePackItem::set_attribute(const ::std::string& value) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(value);
}
inline void EnhancePackItem::set_attribute(const char* value) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(value);
}
inline void EnhancePackItem::set_attribute(const char* value, size_t size) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EnhancePackItem::mutable_attribute() {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  return attribute_;
}
inline ::std::string* EnhancePackItem::release_attribute() {
  clear_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attribute_;
    attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EnhancePackItem::set_allocated_attribute(::std::string* attribute) {
  if (attribute_ != &::google::protobuf::internal::kEmptyString) {
    delete attribute_;
  }
  if (attribute) {
    set_has_attribute();
    attribute_ = attribute;
  } else {
    clear_has_attribute();
    attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RevivePackItem

// required float health_wound_healed = 1;
inline bool RevivePackItem::has_health_wound_healed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RevivePackItem::set_has_health_wound_healed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RevivePackItem::clear_has_health_wound_healed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RevivePackItem::clear_health_wound_healed() {
  health_wound_healed_ = 0;
  clear_has_health_wound_healed();
}
inline float RevivePackItem::health_wound_healed() const {
  return health_wound_healed_;
}
inline void RevivePackItem::set_health_wound_healed(float value) {
  set_has_health_wound_healed();
  health_wound_healed_ = value;
}

// required float health_healed = 2;
inline bool RevivePackItem::has_health_healed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RevivePackItem::set_has_health_healed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RevivePackItem::clear_has_health_healed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RevivePackItem::clear_health_healed() {
  health_healed_ = 0;
  clear_has_health_healed();
}
inline float RevivePackItem::health_healed() const {
  return health_healed_;
}
inline void RevivePackItem::set_health_healed(float value) {
  set_has_health_healed();
  health_healed_ = value;
}

// required float action_wound_healed = 3;
inline bool RevivePackItem::has_action_wound_healed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RevivePackItem::set_has_action_wound_healed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RevivePackItem::clear_has_action_wound_healed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RevivePackItem::clear_action_wound_healed() {
  action_wound_healed_ = 0;
  clear_has_action_wound_healed();
}
inline float RevivePackItem::action_wound_healed() const {
  return action_wound_healed_;
}
inline void RevivePackItem::set_action_wound_healed(float value) {
  set_has_action_wound_healed();
  action_wound_healed_ = value;
}

// required float action_healed = 4;
inline bool RevivePackItem::has_action_healed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RevivePackItem::set_has_action_healed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RevivePackItem::clear_has_action_healed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RevivePackItem::clear_action_healed() {
  action_healed_ = 0;
  clear_has_action_healed();
}
inline float RevivePackItem::action_healed() const {
  return action_healed_;
}
inline void RevivePackItem::set_action_healed(float value) {
  set_has_action_healed();
  action_healed_ = value;
}

// required float mind_wound_healed = 5;
inline bool RevivePackItem::has_mind_wound_healed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RevivePackItem::set_has_mind_wound_healed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RevivePackItem::clear_has_mind_wound_healed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RevivePackItem::clear_mind_wound_healed() {
  mind_wound_healed_ = 0;
  clear_has_mind_wound_healed();
}
inline float RevivePackItem::mind_wound_healed() const {
  return mind_wound_healed_;
}
inline void RevivePackItem::set_mind_wound_healed(float value) {
  set_has_mind_wound_healed();
  mind_wound_healed_ = value;
}

// required float mind_healed = 6;
inline bool RevivePackItem::has_mind_healed() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RevivePackItem::set_has_mind_healed() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RevivePackItem::clear_has_mind_healed() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RevivePackItem::clear_mind_healed() {
  mind_healed_ = 0;
  clear_has_mind_healed();
}
inline float RevivePackItem::mind_healed() const {
  return mind_healed_;
}
inline void RevivePackItem::set_mind_healed(float value) {
  set_has_mind_healed();
  mind_healed_ = value;
}

// -------------------------------------------------------------------

// WoundPackItem

// required string attribute = 1;
inline bool WoundPackItem::has_attribute() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WoundPackItem::set_has_attribute() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WoundPackItem::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WoundPackItem::clear_attribute() {
  if (attribute_ != &::google::protobuf::internal::kEmptyString) {
    attribute_->clear();
  }
  clear_has_attribute();
}
inline const ::std::string& WoundPackItem::attribute() const {
  return *attribute_;
}
inline void WoundPackItem::set_attribute(const ::std::string& value) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(value);
}
inline void WoundPackItem::set_attribute(const char* value) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(value);
}
inline void WoundPackItem::set_attribute(const char* value, size_t size) {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  attribute_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WoundPackItem::mutable_attribute() {
  set_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    attribute_ = new ::std::string;
  }
  return attribute_;
}
inline ::std::string* WoundPackItem::release_attribute() {
  clear_has_attribute();
  if (attribute_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attribute_;
    attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WoundPackItem::set_allocated_attribute(::std::string* attribute) {
  if (attribute_ != &::google::protobuf::internal::kEmptyString) {
    delete attribute_;
  }
  if (attribute) {
    set_has_attribute();
    attribute_ = attribute;
  } else {
    clear_has_attribute();
    attribute_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CraftingComponentItem

// repeated .swgemurpcserver.rpc.CraftingComponentAttribute attributes = 1;
inline int CraftingComponentItem::attributes_size() const {
  return attributes_.size();
}
inline void CraftingComponentItem::clear_attributes() {
  attributes_.Clear();
}
inline const ::swgemurpcserver::rpc::CraftingComponentAttribute& CraftingComponentItem::attributes(int index) const {
  return attributes_.Get(index);
}
inline ::swgemurpcserver::rpc::CraftingComponentAttribute* CraftingComponentItem::mutable_attributes(int index) {
  return attributes_.Mutable(index);
}
inline ::swgemurpcserver::rpc::CraftingComponentAttribute* CraftingComponentItem::add_attributes() {
  return attributes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CraftingComponentAttribute >&
CraftingComponentItem::attributes() const {
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CraftingComponentAttribute >*
CraftingComponentItem::mutable_attributes() {
  return &attributes_;
}

// -------------------------------------------------------------------

// CraftingComponentAttribute

// required string id = 1;
inline bool CraftingComponentAttribute::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CraftingComponentAttribute::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CraftingComponentAttribute::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CraftingComponentAttribute::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& CraftingComponentAttribute::id() const {
  return *id_;
}
inline void CraftingComponentAttribute::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CraftingComponentAttribute::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void CraftingComponentAttribute::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CraftingComponentAttribute::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* CraftingComponentAttribute::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CraftingComponentAttribute::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string tite = 2;
inline bool CraftingComponentAttribute::has_tite() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CraftingComponentAttribute::set_has_tite() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CraftingComponentAttribute::clear_has_tite() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CraftingComponentAttribute::clear_tite() {
  if (tite_ != &::google::protobuf::internal::kEmptyString) {
    tite_->clear();
  }
  clear_has_tite();
}
inline const ::std::string& CraftingComponentAttribute::tite() const {
  return *tite_;
}
inline void CraftingComponentAttribute::set_tite(const ::std::string& value) {
  set_has_tite();
  if (tite_ == &::google::protobuf::internal::kEmptyString) {
    tite_ = new ::std::string;
  }
  tite_->assign(value);
}
inline void CraftingComponentAttribute::set_tite(const char* value) {
  set_has_tite();
  if (tite_ == &::google::protobuf::internal::kEmptyString) {
    tite_ = new ::std::string;
  }
  tite_->assign(value);
}
inline void CraftingComponentAttribute::set_tite(const char* value, size_t size) {
  set_has_tite();
  if (tite_ == &::google::protobuf::internal::kEmptyString) {
    tite_ = new ::std::string;
  }
  tite_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CraftingComponentAttribute::mutable_tite() {
  set_has_tite();
  if (tite_ == &::google::protobuf::internal::kEmptyString) {
    tite_ = new ::std::string;
  }
  return tite_;
}
inline ::std::string* CraftingComponentAttribute::release_tite() {
  clear_has_tite();
  if (tite_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tite_;
    tite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CraftingComponentAttribute::set_allocated_tite(::std::string* tite) {
  if (tite_ != &::google::protobuf::internal::kEmptyString) {
    delete tite_;
  }
  if (tite) {
    set_has_tite();
    tite_ = tite;
  } else {
    clear_has_tite();
    tite_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 precision = 3;
inline bool CraftingComponentAttribute::has_precision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CraftingComponentAttribute::set_has_precision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CraftingComponentAttribute::clear_has_precision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CraftingComponentAttribute::clear_precision() {
  precision_ = 0;
  clear_has_precision();
}
inline ::google::protobuf::int32 CraftingComponentAttribute::precision() const {
  return precision_;
}
inline void CraftingComponentAttribute::set_precision(::google::protobuf::int32 value) {
  set_has_precision();
  precision_ = value;
}

// required float value = 4;
inline bool CraftingComponentAttribute::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CraftingComponentAttribute::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CraftingComponentAttribute::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CraftingComponentAttribute::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float CraftingComponentAttribute::value() const {
  return value_;
}
inline void CraftingComponentAttribute::set_value(float value) {
  set_has_value();
  value_ = value;
}

// required bool hidden = 5;
inline bool CraftingComponentAttribute::has_hidden() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CraftingComponentAttribute::set_has_hidden() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CraftingComponentAttribute::clear_has_hidden() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CraftingComponentAttribute::clear_hidden() {
  hidden_ = false;
  clear_has_hidden();
}
inline bool CraftingComponentAttribute::hidden() const {
  return hidden_;
}
inline void CraftingComponentAttribute::set_hidden(bool value) {
  set_has_hidden();
  hidden_ = value;
}

// -------------------------------------------------------------------

// ManufacturingSchematicItem

// required int32 manufacture_limit = 1;
inline bool ManufacturingSchematicItem::has_manufacture_limit() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ManufacturingSchematicItem::set_has_manufacture_limit() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ManufacturingSchematicItem::clear_has_manufacture_limit() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ManufacturingSchematicItem::clear_manufacture_limit() {
  manufacture_limit_ = 0;
  clear_has_manufacture_limit();
}
inline ::google::protobuf::int32 ManufacturingSchematicItem::manufacture_limit() const {
  return manufacture_limit_;
}
inline void ManufacturingSchematicItem::set_manufacture_limit(::google::protobuf::int32 value) {
  set_has_manufacture_limit();
  manufacture_limit_ = value;
}

// required .swgemurpcserver.rpc.CharacterInventoryItem prototype_details = 2;
inline bool ManufacturingSchematicItem::has_prototype_details() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ManufacturingSchematicItem::set_has_prototype_details() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ManufacturingSchematicItem::clear_has_prototype_details() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ManufacturingSchematicItem::clear_prototype_details() {
  if (prototype_details_ != NULL) prototype_details_->::swgemurpcserver::rpc::CharacterInventoryItem::Clear();
  clear_has_prototype_details();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& ManufacturingSchematicItem::prototype_details() const {
  return prototype_details_ != NULL ? *prototype_details_ : *default_instance_->prototype_details_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* ManufacturingSchematicItem::mutable_prototype_details() {
  set_has_prototype_details();
  if (prototype_details_ == NULL) prototype_details_ = new ::swgemurpcserver::rpc::CharacterInventoryItem;
  return prototype_details_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* ManufacturingSchematicItem::release_prototype_details() {
  clear_has_prototype_details();
  ::swgemurpcserver::rpc::CharacterInventoryItem* temp = prototype_details_;
  prototype_details_ = NULL;
  return temp;
}
inline void ManufacturingSchematicItem::set_allocated_prototype_details(::swgemurpcserver::rpc::CharacterInventoryItem* prototype_details) {
  delete prototype_details_;
  prototype_details_ = prototype_details;
  if (prototype_details) {
    set_has_prototype_details();
  } else {
    clear_has_prototype_details();
  }
}

// repeated .swgemurpcserver.rpc.BlueprintEntryItem blueprint_entries = 3;
inline int ManufacturingSchematicItem::blueprint_entries_size() const {
  return blueprint_entries_.size();
}
inline void ManufacturingSchematicItem::clear_blueprint_entries() {
  blueprint_entries_.Clear();
}
inline const ::swgemurpcserver::rpc::BlueprintEntryItem& ManufacturingSchematicItem::blueprint_entries(int index) const {
  return blueprint_entries_.Get(index);
}
inline ::swgemurpcserver::rpc::BlueprintEntryItem* ManufacturingSchematicItem::mutable_blueprint_entries(int index) {
  return blueprint_entries_.Mutable(index);
}
inline ::swgemurpcserver::rpc::BlueprintEntryItem* ManufacturingSchematicItem::add_blueprint_entries() {
  return blueprint_entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::BlueprintEntryItem >&
ManufacturingSchematicItem::blueprint_entries() const {
  return blueprint_entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::BlueprintEntryItem >*
ManufacturingSchematicItem::mutable_blueprint_entries() {
  return &blueprint_entries_;
}

// repeated .swgemurpcserver.rpc.IngredientItem ingredients = 4;
inline int ManufacturingSchematicItem::ingredients_size() const {
  return ingredients_.size();
}
inline void ManufacturingSchematicItem::clear_ingredients() {
  ingredients_.Clear();
}
inline const ::swgemurpcserver::rpc::IngredientItem& ManufacturingSchematicItem::ingredients(int index) const {
  return ingredients_.Get(index);
}
inline ::swgemurpcserver::rpc::IngredientItem* ManufacturingSchematicItem::mutable_ingredients(int index) {
  return ingredients_.Mutable(index);
}
inline ::swgemurpcserver::rpc::IngredientItem* ManufacturingSchematicItem::add_ingredients() {
  return ingredients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::IngredientItem >&
ManufacturingSchematicItem::ingredients() const {
  return ingredients_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::IngredientItem >*
ManufacturingSchematicItem::mutable_ingredients() {
  return &ingredients_;
}

// -------------------------------------------------------------------

// IngredientItem

// required int32 required_quantity = 1;
inline bool IngredientItem::has_required_quantity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IngredientItem::set_has_required_quantity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IngredientItem::clear_has_required_quantity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IngredientItem::clear_required_quantity() {
  required_quantity_ = 0;
  clear_has_required_quantity();
}
inline ::google::protobuf::int32 IngredientItem::required_quantity() const {
  return required_quantity_;
}
inline void IngredientItem::set_required_quantity(::google::protobuf::int32 value) {
  set_has_required_quantity();
  required_quantity_ = value;
}

// required bool identical = 2;
inline bool IngredientItem::has_identical() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IngredientItem::set_has_identical() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IngredientItem::clear_has_identical() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IngredientItem::clear_identical() {
  identical_ = false;
  clear_has_identical();
}
inline bool IngredientItem::identical() const {
  return identical_;
}
inline void IngredientItem::set_identical(bool value) {
  set_has_identical();
  identical_ = value;
}

// required string ingredient_slot_name = 3;
inline bool IngredientItem::has_ingredient_slot_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IngredientItem::set_has_ingredient_slot_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IngredientItem::clear_has_ingredient_slot_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IngredientItem::clear_ingredient_slot_name() {
  if (ingredient_slot_name_ != &::google::protobuf::internal::kEmptyString) {
    ingredient_slot_name_->clear();
  }
  clear_has_ingredient_slot_name();
}
inline const ::std::string& IngredientItem::ingredient_slot_name() const {
  return *ingredient_slot_name_;
}
inline void IngredientItem::set_ingredient_slot_name(const ::std::string& value) {
  set_has_ingredient_slot_name();
  if (ingredient_slot_name_ == &::google::protobuf::internal::kEmptyString) {
    ingredient_slot_name_ = new ::std::string;
  }
  ingredient_slot_name_->assign(value);
}
inline void IngredientItem::set_ingredient_slot_name(const char* value) {
  set_has_ingredient_slot_name();
  if (ingredient_slot_name_ == &::google::protobuf::internal::kEmptyString) {
    ingredient_slot_name_ = new ::std::string;
  }
  ingredient_slot_name_->assign(value);
}
inline void IngredientItem::set_ingredient_slot_name(const char* value, size_t size) {
  set_has_ingredient_slot_name();
  if (ingredient_slot_name_ == &::google::protobuf::internal::kEmptyString) {
    ingredient_slot_name_ = new ::std::string;
  }
  ingredient_slot_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IngredientItem::mutable_ingredient_slot_name() {
  set_has_ingredient_slot_name();
  if (ingredient_slot_name_ == &::google::protobuf::internal::kEmptyString) {
    ingredient_slot_name_ = new ::std::string;
  }
  return ingredient_slot_name_;
}
inline ::std::string* IngredientItem::release_ingredient_slot_name() {
  clear_has_ingredient_slot_name();
  if (ingredient_slot_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ingredient_slot_name_;
    ingredient_slot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IngredientItem::set_allocated_ingredient_slot_name(::std::string* ingredient_slot_name) {
  if (ingredient_slot_name_ != &::google::protobuf::internal::kEmptyString) {
    delete ingredient_slot_name_;
  }
  if (ingredient_slot_name) {
    set_has_ingredient_slot_name();
    ingredient_slot_name_ = ingredient_slot_name;
  } else {
    clear_has_ingredient_slot_name();
    ingredient_slot_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .swgemurpcserver.rpc.CharacterInventoryItem ingredient = 4;
inline bool IngredientItem::has_ingredient() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IngredientItem::set_has_ingredient() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IngredientItem::clear_has_ingredient() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IngredientItem::clear_ingredient() {
  if (ingredient_ != NULL) ingredient_->::swgemurpcserver::rpc::CharacterInventoryItem::Clear();
  clear_has_ingredient();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& IngredientItem::ingredient() const {
  return ingredient_ != NULL ? *ingredient_ : *default_instance_->ingredient_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* IngredientItem::mutable_ingredient() {
  set_has_ingredient();
  if (ingredient_ == NULL) ingredient_ = new ::swgemurpcserver::rpc::CharacterInventoryItem;
  return ingredient_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* IngredientItem::release_ingredient() {
  clear_has_ingredient();
  ::swgemurpcserver::rpc::CharacterInventoryItem* temp = ingredient_;
  ingredient_ = NULL;
  return temp;
}
inline void IngredientItem::set_allocated_ingredient(::swgemurpcserver::rpc::CharacterInventoryItem* ingredient) {
  delete ingredient_;
  ingredient_ = ingredient;
  if (ingredient) {
    set_has_ingredient();
  } else {
    clear_has_ingredient();
  }
}

// -------------------------------------------------------------------

// BlueprintEntryItem

// required string type = 1;
inline bool BlueprintEntryItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlueprintEntryItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlueprintEntryItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlueprintEntryItem::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& BlueprintEntryItem::type() const {
  return *type_;
}
inline void BlueprintEntryItem::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BlueprintEntryItem::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void BlueprintEntryItem::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlueprintEntryItem::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* BlueprintEntryItem::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlueprintEntryItem::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string key = 2;
inline bool BlueprintEntryItem::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlueprintEntryItem::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlueprintEntryItem::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlueprintEntryItem::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& BlueprintEntryItem::key() const {
  return *key_;
}
inline void BlueprintEntryItem::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void BlueprintEntryItem::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void BlueprintEntryItem::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlueprintEntryItem::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* BlueprintEntryItem::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlueprintEntryItem::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string serial = 3;
inline bool BlueprintEntryItem::has_serial() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlueprintEntryItem::set_has_serial() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlueprintEntryItem::clear_has_serial() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlueprintEntryItem::clear_serial() {
  if (serial_ != &::google::protobuf::internal::kEmptyString) {
    serial_->clear();
  }
  clear_has_serial();
}
inline const ::std::string& BlueprintEntryItem::serial() const {
  return *serial_;
}
inline void BlueprintEntryItem::set_serial(const ::std::string& value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void BlueprintEntryItem::set_serial(const char* value) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(value);
}
inline void BlueprintEntryItem::set_serial(const char* value, size_t size) {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  serial_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlueprintEntryItem::mutable_serial() {
  set_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    serial_ = new ::std::string;
  }
  return serial_;
}
inline ::std::string* BlueprintEntryItem::release_serial() {
  clear_has_serial();
  if (serial_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serial_;
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlueprintEntryItem::set_allocated_serial(::std::string* serial) {
  if (serial_ != &::google::protobuf::internal::kEmptyString) {
    delete serial_;
  }
  if (serial) {
    set_has_serial();
    serial_ = serial;
  } else {
    clear_has_serial();
    serial_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string display_name = 4;
inline bool BlueprintEntryItem::has_display_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlueprintEntryItem::set_has_display_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlueprintEntryItem::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlueprintEntryItem::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& BlueprintEntryItem::display_name() const {
  return *display_name_;
}
inline void BlueprintEntryItem::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void BlueprintEntryItem::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void BlueprintEntryItem::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlueprintEntryItem::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* BlueprintEntryItem::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlueprintEntryItem::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 quantity = 5;
inline bool BlueprintEntryItem::has_quantity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlueprintEntryItem::set_has_quantity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlueprintEntryItem::clear_has_quantity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlueprintEntryItem::clear_quantity() {
  quantity_ = 0;
  clear_has_quantity();
}
inline ::google::protobuf::int32 BlueprintEntryItem::quantity() const {
  return quantity_;
}
inline void BlueprintEntryItem::set_quantity(::google::protobuf::int32 value) {
  set_has_quantity();
  quantity_ = value;
}

// required bool identical = 6;
inline bool BlueprintEntryItem::has_identical() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlueprintEntryItem::set_has_identical() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlueprintEntryItem::clear_has_identical() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlueprintEntryItem::clear_identical() {
  identical_ = false;
  clear_has_identical();
}
inline bool BlueprintEntryItem::identical() const {
  return identical_;
}
inline void BlueprintEntryItem::set_identical(bool value) {
  set_has_identical();
  identical_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace swgemurpcserver

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType>() {
  return ::swgemurpcserver::rpc::PharmaceuticalItem_PharmaceuticalItemType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_InventoryItem_2eproto__INCLUDED
