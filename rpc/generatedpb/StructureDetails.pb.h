// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: StructureDetails.proto

#ifndef PROTOBUF_StructureDetails_2eproto__INCLUDED
#define PROTOBUF_StructureDetails_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "InventoryItem.pb.h"
// @@protoc_insertion_point(includes)

namespace swgemurpcserver {
namespace rpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_StructureDetails_2eproto();
void protobuf_AssignDesc_StructureDetails_2eproto();
void protobuf_ShutdownFile_StructureDetails_2eproto();

class SWGEmuStructureItemDetails;
class BuildingItemDetails;
class InstallationItemDetails;
class HarvesterItemDetails;
class FactoryItemDetails;
class GetStructureItemDetailsRequest;
class GetStructureItemDetailsResponse;

// ===================================================================

class SWGEmuStructureItemDetails : public ::google::protobuf::Message {
 public:
  SWGEmuStructureItemDetails();
  virtual ~SWGEmuStructureItemDetails();

  SWGEmuStructureItemDetails(const SWGEmuStructureItemDetails& from);

  inline SWGEmuStructureItemDetails& operator=(const SWGEmuStructureItemDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SWGEmuStructureItemDetails& default_instance();

  void Swap(SWGEmuStructureItemDetails* other);

  // implements Message ----------------------------------------------

  SWGEmuStructureItemDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SWGEmuStructureItemDetails& from);
  void MergeFrom(const SWGEmuStructureItemDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 object_id = 1;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  inline ::google::protobuf::uint64 object_id() const;
  inline void set_object_id(::google::protobuf::uint64 value);

  // required string appearance_file_name = 2;
  inline bool has_appearance_file_name() const;
  inline void clear_appearance_file_name();
  static const int kAppearanceFileNameFieldNumber = 2;
  inline const ::std::string& appearance_file_name() const;
  inline void set_appearance_file_name(const ::std::string& value);
  inline void set_appearance_file_name(const char* value);
  inline void set_appearance_file_name(const char* value, size_t size);
  inline ::std::string* mutable_appearance_file_name();
  inline ::std::string* release_appearance_file_name();
  inline void set_allocated_appearance_file_name(::std::string* appearance_file_name);

  // required string object_name = 3;
  inline bool has_object_name() const;
  inline void clear_object_name();
  static const int kObjectNameFieldNumber = 3;
  inline const ::std::string& object_name() const;
  inline void set_object_name(const ::std::string& value);
  inline void set_object_name(const char* value);
  inline void set_object_name(const char* value, size_t size);
  inline ::std::string* mutable_object_name();
  inline ::std::string* release_object_name();
  inline void set_allocated_object_name(::std::string* object_name);

  // required string display_name = 4;
  inline bool has_display_name() const;
  inline void clear_display_name();
  static const int kDisplayNameFieldNumber = 4;
  inline const ::std::string& display_name() const;
  inline void set_display_name(const ::std::string& value);
  inline void set_display_name(const char* value);
  inline void set_display_name(const char* value, size_t size);
  inline ::std::string* mutable_display_name();
  inline ::std::string* release_display_name();
  inline void set_allocated_display_name(::std::string* display_name);

  // required string owner_display_name = 5;
  inline bool has_owner_display_name() const;
  inline void clear_owner_display_name();
  static const int kOwnerDisplayNameFieldNumber = 5;
  inline const ::std::string& owner_display_name() const;
  inline void set_owner_display_name(const ::std::string& value);
  inline void set_owner_display_name(const char* value);
  inline void set_owner_display_name(const char* value, size_t size);
  inline ::std::string* mutable_owner_display_name();
  inline ::std::string* release_owner_display_name();
  inline void set_allocated_owner_display_name(::std::string* owner_display_name);

  // optional float world_x = 6;
  inline bool has_world_x() const;
  inline void clear_world_x();
  static const int kWorldXFieldNumber = 6;
  inline float world_x() const;
  inline void set_world_x(float value);

  // optional float world_y = 7;
  inline bool has_world_y() const;
  inline void clear_world_y();
  static const int kWorldYFieldNumber = 7;
  inline float world_y() const;
  inline void set_world_y(float value);

  // optional float world_z = 8;
  inline bool has_world_z() const;
  inline void clear_world_z();
  static const int kWorldZFieldNumber = 8;
  inline float world_z() const;
  inline void set_world_z(float value);

  // optional string zone = 9;
  inline bool has_zone() const;
  inline void clear_zone();
  static const int kZoneFieldNumber = 9;
  inline const ::std::string& zone() const;
  inline void set_zone(const ::std::string& value);
  inline void set_zone(const char* value);
  inline void set_zone(const char* value, size_t size);
  inline ::std::string* mutable_zone();
  inline ::std::string* release_zone();
  inline void set_allocated_zone(::std::string* zone);

  // optional int32 power = 10;
  inline bool has_power() const;
  inline void clear_power();
  static const int kPowerFieldNumber = 10;
  inline ::google::protobuf::int32 power() const;
  inline void set_power(::google::protobuf::int32 value);

  // optional int32 maintenance = 11;
  inline bool has_maintenance() const;
  inline void clear_maintenance();
  static const int kMaintenanceFieldNumber = 11;
  inline ::google::protobuf::int32 maintenance() const;
  inline void set_maintenance(::google::protobuf::int32 value);

  // optional int32 decay_percent = 12;
  inline bool has_decay_percent() const;
  inline void clear_decay_percent();
  static const int kDecayPercentFieldNumber = 12;
  inline ::google::protobuf::int32 decay_percent() const;
  inline void set_decay_percent(::google::protobuf::int32 value);

  // optional int32 lot_size = 13;
  inline bool has_lot_size() const;
  inline void clear_lot_size();
  static const int kLotSizeFieldNumber = 13;
  inline ::google::protobuf::int32 lot_size() const;
  inline void set_lot_size(::google::protobuf::int32 value);

  // optional string template_file_name = 14;
  inline bool has_template_file_name() const;
  inline void clear_template_file_name();
  static const int kTemplateFileNameFieldNumber = 14;
  inline const ::std::string& template_file_name() const;
  inline void set_template_file_name(const ::std::string& value);
  inline void set_template_file_name(const char* value);
  inline void set_template_file_name(const char* value, size_t size);
  inline ::std::string* mutable_template_file_name();
  inline ::std::string* release_template_file_name();
  inline void set_allocated_template_file_name(::std::string* template_file_name);

  // optional string portals_file_name = 15;
  inline bool has_portals_file_name() const;
  inline void clear_portals_file_name();
  static const int kPortalsFileNameFieldNumber = 15;
  inline const ::std::string& portals_file_name() const;
  inline void set_portals_file_name(const ::std::string& value);
  inline void set_portals_file_name(const char* value);
  inline void set_portals_file_name(const char* value, size_t size);
  inline ::std::string* mutable_portals_file_name();
  inline ::std::string* release_portals_file_name();
  inline void set_allocated_portals_file_name(::std::string* portals_file_name);

  // repeated string buildable_zones = 16;
  inline int buildable_zones_size() const;
  inline void clear_buildable_zones();
  static const int kBuildableZonesFieldNumber = 16;
  inline const ::std::string& buildable_zones(int index) const;
  inline ::std::string* mutable_buildable_zones(int index);
  inline void set_buildable_zones(int index, const ::std::string& value);
  inline void set_buildable_zones(int index, const char* value);
  inline void set_buildable_zones(int index, const char* value, size_t size);
  inline ::std::string* add_buildable_zones();
  inline void add_buildable_zones(const ::std::string& value);
  inline void add_buildable_zones(const char* value);
  inline void add_buildable_zones(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buildable_zones() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buildable_zones();

  // optional .swgemurpcserver.rpc.BuildingItemDetails building_details = 20;
  inline bool has_building_details() const;
  inline void clear_building_details();
  static const int kBuildingDetailsFieldNumber = 20;
  inline const ::swgemurpcserver::rpc::BuildingItemDetails& building_details() const;
  inline ::swgemurpcserver::rpc::BuildingItemDetails* mutable_building_details();
  inline ::swgemurpcserver::rpc::BuildingItemDetails* release_building_details();
  inline void set_allocated_building_details(::swgemurpcserver::rpc::BuildingItemDetails* building_details);

  // optional .swgemurpcserver.rpc.InstallationItemDetails installation_details = 21;
  inline bool has_installation_details() const;
  inline void clear_installation_details();
  static const int kInstallationDetailsFieldNumber = 21;
  inline const ::swgemurpcserver::rpc::InstallationItemDetails& installation_details() const;
  inline ::swgemurpcserver::rpc::InstallationItemDetails* mutable_installation_details();
  inline ::swgemurpcserver::rpc::InstallationItemDetails* release_installation_details();
  inline void set_allocated_installation_details(::swgemurpcserver::rpc::InstallationItemDetails* installation_details);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.SWGEmuStructureItemDetails)
 private:
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_appearance_file_name();
  inline void clear_has_appearance_file_name();
  inline void set_has_object_name();
  inline void clear_has_object_name();
  inline void set_has_display_name();
  inline void clear_has_display_name();
  inline void set_has_owner_display_name();
  inline void clear_has_owner_display_name();
  inline void set_has_world_x();
  inline void clear_has_world_x();
  inline void set_has_world_y();
  inline void clear_has_world_y();
  inline void set_has_world_z();
  inline void clear_has_world_z();
  inline void set_has_zone();
  inline void clear_has_zone();
  inline void set_has_power();
  inline void clear_has_power();
  inline void set_has_maintenance();
  inline void clear_has_maintenance();
  inline void set_has_decay_percent();
  inline void clear_has_decay_percent();
  inline void set_has_lot_size();
  inline void clear_has_lot_size();
  inline void set_has_template_file_name();
  inline void clear_has_template_file_name();
  inline void set_has_portals_file_name();
  inline void clear_has_portals_file_name();
  inline void set_has_building_details();
  inline void clear_has_building_details();
  inline void set_has_installation_details();
  inline void clear_has_installation_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 object_id_;
  ::std::string* appearance_file_name_;
  ::std::string* object_name_;
  ::std::string* display_name_;
  ::std::string* owner_display_name_;
  float world_x_;
  float world_y_;
  ::std::string* zone_;
  float world_z_;
  ::google::protobuf::int32 power_;
  ::google::protobuf::int32 maintenance_;
  ::google::protobuf::int32 decay_percent_;
  ::std::string* template_file_name_;
  ::std::string* portals_file_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> buildable_zones_;
  ::swgemurpcserver::rpc::BuildingItemDetails* building_details_;
  ::swgemurpcserver::rpc::InstallationItemDetails* installation_details_;
  ::google::protobuf::int32 lot_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static SWGEmuStructureItemDetails* default_instance_;
};
// -------------------------------------------------------------------

class BuildingItemDetails : public ::google::protobuf::Message {
 public:
  BuildingItemDetails();
  virtual ~BuildingItemDetails();

  BuildingItemDetails(const BuildingItemDetails& from);

  inline BuildingItemDetails& operator=(const BuildingItemDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BuildingItemDetails& default_instance();

  void Swap(BuildingItemDetails* other);

  // implements Message ----------------------------------------------

  BuildingItemDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BuildingItemDetails& from);
  void MergeFrom(const BuildingItemDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .swgemurpcserver.rpc.CharacterInventoryItem contained_items = 1;
  inline int contained_items_size() const;
  inline void clear_contained_items();
  static const int kContainedItemsFieldNumber = 1;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& contained_items(int index) const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_contained_items(int index);
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* add_contained_items();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
      contained_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
      mutable_contained_items();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.BuildingItemDetails)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem > contained_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static BuildingItemDetails* default_instance_;
};
// -------------------------------------------------------------------

class InstallationItemDetails : public ::google::protobuf::Message {
 public:
  InstallationItemDetails();
  virtual ~InstallationItemDetails();

  InstallationItemDetails(const InstallationItemDetails& from);

  inline InstallationItemDetails& operator=(const InstallationItemDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InstallationItemDetails& default_instance();

  void Swap(InstallationItemDetails* other);

  // implements Message ----------------------------------------------

  InstallationItemDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InstallationItemDetails& from);
  void MergeFrom(const InstallationItemDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool operating = 1;
  inline bool has_operating() const;
  inline void clear_operating();
  static const int kOperatingFieldNumber = 1;
  inline bool operating() const;
  inline void set_operating(bool value);

  // required float actual_rate = 2;
  inline bool has_actual_rate() const;
  inline void clear_actual_rate();
  static const int kActualRateFieldNumber = 2;
  inline float actual_rate() const;
  inline void set_actual_rate(float value);

  // required float max_hopper_size = 3;
  inline bool has_max_hopper_size() const;
  inline void clear_max_hopper_size();
  static const int kMaxHopperSizeFieldNumber = 3;
  inline float max_hopper_size() const;
  inline void set_max_hopper_size(float value);

  // optional .swgemurpcserver.rpc.HarvesterItemDetails harvester_details = 4;
  inline bool has_harvester_details() const;
  inline void clear_harvester_details();
  static const int kHarvesterDetailsFieldNumber = 4;
  inline const ::swgemurpcserver::rpc::HarvesterItemDetails& harvester_details() const;
  inline ::swgemurpcserver::rpc::HarvesterItemDetails* mutable_harvester_details();
  inline ::swgemurpcserver::rpc::HarvesterItemDetails* release_harvester_details();
  inline void set_allocated_harvester_details(::swgemurpcserver::rpc::HarvesterItemDetails* harvester_details);

  // optional .swgemurpcserver.rpc.FactoryItemDetails factory_details = 5;
  inline bool has_factory_details() const;
  inline void clear_factory_details();
  static const int kFactoryDetailsFieldNumber = 5;
  inline const ::swgemurpcserver::rpc::FactoryItemDetails& factory_details() const;
  inline ::swgemurpcserver::rpc::FactoryItemDetails* mutable_factory_details();
  inline ::swgemurpcserver::rpc::FactoryItemDetails* release_factory_details();
  inline void set_allocated_factory_details(::swgemurpcserver::rpc::FactoryItemDetails* factory_details);

  // repeated .swgemurpcserver.rpc.CharacterInventoryItem hopper_items = 10;
  inline int hopper_items_size() const;
  inline void clear_hopper_items();
  static const int kHopperItemsFieldNumber = 10;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& hopper_items(int index) const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_hopper_items(int index);
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* add_hopper_items();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
      hopper_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
      mutable_hopper_items();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.InstallationItemDetails)
 private:
  inline void set_has_operating();
  inline void clear_has_operating();
  inline void set_has_actual_rate();
  inline void clear_has_actual_rate();
  inline void set_has_max_hopper_size();
  inline void clear_has_max_hopper_size();
  inline void set_has_harvester_details();
  inline void clear_has_harvester_details();
  inline void set_has_factory_details();
  inline void clear_has_factory_details();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool operating_;
  float actual_rate_;
  ::swgemurpcserver::rpc::HarvesterItemDetails* harvester_details_;
  ::swgemurpcserver::rpc::FactoryItemDetails* factory_details_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem > hopper_items_;
  float max_hopper_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static InstallationItemDetails* default_instance_;
};
// -------------------------------------------------------------------

class HarvesterItemDetails : public ::google::protobuf::Message {
 public:
  HarvesterItemDetails();
  virtual ~HarvesterItemDetails();

  HarvesterItemDetails(const HarvesterItemDetails& from);

  inline HarvesterItemDetails& operator=(const HarvesterItemDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HarvesterItemDetails& default_instance();

  void Swap(HarvesterItemDetails* other);

  // implements Message ----------------------------------------------

  HarvesterItemDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HarvesterItemDetails& from);
  void MergeFrom(const HarvesterItemDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float extraction_rate = 1;
  inline bool has_extraction_rate() const;
  inline void clear_extraction_rate();
  static const int kExtractionRateFieldNumber = 1;
  inline float extraction_rate() const;
  inline void set_extraction_rate(float value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.HarvesterItemDetails)
 private:
  inline void set_has_extraction_rate();
  inline void clear_has_extraction_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float extraction_rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static HarvesterItemDetails* default_instance_;
};
// -------------------------------------------------------------------

class FactoryItemDetails : public ::google::protobuf::Message {
 public:
  FactoryItemDetails();
  virtual ~FactoryItemDetails();

  FactoryItemDetails(const FactoryItemDetails& from);

  inline FactoryItemDetails& operator=(const FactoryItemDetails& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FactoryItemDetails& default_instance();

  void Swap(FactoryItemDetails* other);

  // implements Message ----------------------------------------------

  FactoryItemDetails* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FactoryItemDetails& from);
  void MergeFrom(const FactoryItemDetails& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .swgemurpcserver.rpc.CharacterInventoryItem schematic = 1;
  inline bool has_schematic() const;
  inline void clear_schematic();
  static const int kSchematicFieldNumber = 1;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& schematic() const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_schematic();
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* release_schematic();
  inline void set_allocated_schematic(::swgemurpcserver::rpc::CharacterInventoryItem* schematic);

  // repeated .swgemurpcserver.rpc.CharacterInventoryItem ingredient_items = 10;
  inline int ingredient_items_size() const;
  inline void clear_ingredient_items();
  static const int kIngredientItemsFieldNumber = 10;
  inline const ::swgemurpcserver::rpc::CharacterInventoryItem& ingredient_items(int index) const;
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* mutable_ingredient_items(int index);
  inline ::swgemurpcserver::rpc::CharacterInventoryItem* add_ingredient_items();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
      ingredient_items() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
      mutable_ingredient_items();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.FactoryItemDetails)
 private:
  inline void set_has_schematic();
  inline void clear_has_schematic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::swgemurpcserver::rpc::CharacterInventoryItem* schematic_;
  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem > ingredient_items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static FactoryItemDetails* default_instance_;
};
// -------------------------------------------------------------------

class GetStructureItemDetailsRequest : public ::google::protobuf::Message {
 public:
  GetStructureItemDetailsRequest();
  virtual ~GetStructureItemDetailsRequest();

  GetStructureItemDetailsRequest(const GetStructureItemDetailsRequest& from);

  inline GetStructureItemDetailsRequest& operator=(const GetStructureItemDetailsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStructureItemDetailsRequest& default_instance();

  void Swap(GetStructureItemDetailsRequest* other);

  // implements Message ----------------------------------------------

  GetStructureItemDetailsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStructureItemDetailsRequest& from);
  void MergeFrom(const GetStructureItemDetailsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 object_id = 1;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  inline ::google::protobuf::uint64 object_id() const;
  inline void set_object_id(::google::protobuf::uint64 value);

  // optional fixed64 owner_object_id = 2;
  inline bool has_owner_object_id() const;
  inline void clear_owner_object_id();
  static const int kOwnerObjectIdFieldNumber = 2;
  inline ::google::protobuf::uint64 owner_object_id() const;
  inline void set_owner_object_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.GetStructureItemDetailsRequest)
 private:
  inline void set_has_object_id();
  inline void clear_has_object_id();
  inline void set_has_owner_object_id();
  inline void clear_has_owner_object_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 object_id_;
  ::google::protobuf::uint64 owner_object_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static GetStructureItemDetailsRequest* default_instance_;
};
// -------------------------------------------------------------------

class GetStructureItemDetailsResponse : public ::google::protobuf::Message {
 public:
  GetStructureItemDetailsResponse();
  virtual ~GetStructureItemDetailsResponse();

  GetStructureItemDetailsResponse(const GetStructureItemDetailsResponse& from);

  inline GetStructureItemDetailsResponse& operator=(const GetStructureItemDetailsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetStructureItemDetailsResponse& default_instance();

  void Swap(GetStructureItemDetailsResponse* other);

  // implements Message ----------------------------------------------

  GetStructureItemDetailsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GetStructureItemDetailsResponse& from);
  void MergeFrom(const GetStructureItemDetailsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .swgemurpcserver.rpc.SWGEmuStructureItemDetails structures = 1;
  inline int structures_size() const;
  inline void clear_structures();
  static const int kStructuresFieldNumber = 1;
  inline const ::swgemurpcserver::rpc::SWGEmuStructureItemDetails& structures(int index) const;
  inline ::swgemurpcserver::rpc::SWGEmuStructureItemDetails* mutable_structures(int index);
  inline ::swgemurpcserver::rpc::SWGEmuStructureItemDetails* add_structures();
  inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::SWGEmuStructureItemDetails >&
      structures() const;
  inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::SWGEmuStructureItemDetails >*
      mutable_structures();

  // @@protoc_insertion_point(class_scope:swgemurpcserver.rpc.GetStructureItemDetailsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::SWGEmuStructureItemDetails > structures_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_StructureDetails_2eproto();
  friend void protobuf_AssignDesc_StructureDetails_2eproto();
  friend void protobuf_ShutdownFile_StructureDetails_2eproto();

  void InitAsDefaultInstance();
  static GetStructureItemDetailsResponse* default_instance_;
};
// ===================================================================

class SWGEmuStructureItemDetailsService_Stub;

class SWGEmuStructureItemDetailsService : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SWGEmuStructureItemDetailsService() {};
 public:
  virtual ~SWGEmuStructureItemDetailsService();

  typedef SWGEmuStructureItemDetailsService_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void GetStructureItemDetails(::google::protobuf::RpcController* controller,
                       const ::swgemurpcserver::rpc::GetStructureItemDetailsRequest* request,
                       ::swgemurpcserver::rpc::GetStructureItemDetailsResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SWGEmuStructureItemDetailsService);
};

class SWGEmuStructureItemDetailsService_Stub : public SWGEmuStructureItemDetailsService {
 public:
  SWGEmuStructureItemDetailsService_Stub(::google::protobuf::RpcChannel* channel);
  SWGEmuStructureItemDetailsService_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~SWGEmuStructureItemDetailsService_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements SWGEmuStructureItemDetailsService ------------------------------------------

  void GetStructureItemDetails(::google::protobuf::RpcController* controller,
                       const ::swgemurpcserver::rpc::GetStructureItemDetailsRequest* request,
                       ::swgemurpcserver::rpc::GetStructureItemDetailsResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SWGEmuStructureItemDetailsService_Stub);
};


// ===================================================================


// ===================================================================

// SWGEmuStructureItemDetails

// required fixed64 object_id = 1;
inline bool SWGEmuStructureItemDetails::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SWGEmuStructureItemDetails::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SWGEmuStructureItemDetails::clear_object_id() {
  object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_id();
}
inline ::google::protobuf::uint64 SWGEmuStructureItemDetails::object_id() const {
  return object_id_;
}
inline void SWGEmuStructureItemDetails::set_object_id(::google::protobuf::uint64 value) {
  set_has_object_id();
  object_id_ = value;
}

// required string appearance_file_name = 2;
inline bool SWGEmuStructureItemDetails::has_appearance_file_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_appearance_file_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SWGEmuStructureItemDetails::clear_has_appearance_file_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SWGEmuStructureItemDetails::clear_appearance_file_name() {
  if (appearance_file_name_ != &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_->clear();
  }
  clear_has_appearance_file_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::appearance_file_name() const {
  return *appearance_file_name_;
}
inline void SWGEmuStructureItemDetails::set_appearance_file_name(const ::std::string& value) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_appearance_file_name(const char* value) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_appearance_file_name(const char* value, size_t size) {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  appearance_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_appearance_file_name() {
  set_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    appearance_file_name_ = new ::std::string;
  }
  return appearance_file_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_appearance_file_name() {
  clear_has_appearance_file_name();
  if (appearance_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appearance_file_name_;
    appearance_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_appearance_file_name(::std::string* appearance_file_name) {
  if (appearance_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete appearance_file_name_;
  }
  if (appearance_file_name) {
    set_has_appearance_file_name();
    appearance_file_name_ = appearance_file_name;
  } else {
    clear_has_appearance_file_name();
    appearance_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string object_name = 3;
inline bool SWGEmuStructureItemDetails::has_object_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_object_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SWGEmuStructureItemDetails::clear_has_object_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SWGEmuStructureItemDetails::clear_object_name() {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    object_name_->clear();
  }
  clear_has_object_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::object_name() const {
  return *object_name_;
}
inline void SWGEmuStructureItemDetails::set_object_name(const ::std::string& value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_object_name(const char* value) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_object_name(const char* value, size_t size) {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  object_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_object_name() {
  set_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    object_name_ = new ::std::string;
  }
  return object_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_object_name() {
  clear_has_object_name();
  if (object_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = object_name_;
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_object_name(::std::string* object_name) {
  if (object_name_ != &::google::protobuf::internal::kEmptyString) {
    delete object_name_;
  }
  if (object_name) {
    set_has_object_name();
    object_name_ = object_name;
  } else {
    clear_has_object_name();
    object_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string display_name = 4;
inline bool SWGEmuStructureItemDetails::has_display_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_display_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SWGEmuStructureItemDetails::clear_has_display_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SWGEmuStructureItemDetails::clear_display_name() {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    display_name_->clear();
  }
  clear_has_display_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::display_name() const {
  return *display_name_;
}
inline void SWGEmuStructureItemDetails::set_display_name(const ::std::string& value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_display_name(const char* value) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_display_name(const char* value, size_t size) {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_display_name() {
  set_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    display_name_ = new ::std::string;
  }
  return display_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_display_name() {
  clear_has_display_name();
  if (display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = display_name_;
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_display_name(::std::string* display_name) {
  if (display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete display_name_;
  }
  if (display_name) {
    set_has_display_name();
    display_name_ = display_name;
  } else {
    clear_has_display_name();
    display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string owner_display_name = 5;
inline bool SWGEmuStructureItemDetails::has_owner_display_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_owner_display_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SWGEmuStructureItemDetails::clear_has_owner_display_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SWGEmuStructureItemDetails::clear_owner_display_name() {
  if (owner_display_name_ != &::google::protobuf::internal::kEmptyString) {
    owner_display_name_->clear();
  }
  clear_has_owner_display_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::owner_display_name() const {
  return *owner_display_name_;
}
inline void SWGEmuStructureItemDetails::set_owner_display_name(const ::std::string& value) {
  set_has_owner_display_name();
  if (owner_display_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_display_name_ = new ::std::string;
  }
  owner_display_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_owner_display_name(const char* value) {
  set_has_owner_display_name();
  if (owner_display_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_display_name_ = new ::std::string;
  }
  owner_display_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_owner_display_name(const char* value, size_t size) {
  set_has_owner_display_name();
  if (owner_display_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_display_name_ = new ::std::string;
  }
  owner_display_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_owner_display_name() {
  set_has_owner_display_name();
  if (owner_display_name_ == &::google::protobuf::internal::kEmptyString) {
    owner_display_name_ = new ::std::string;
  }
  return owner_display_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_owner_display_name() {
  clear_has_owner_display_name();
  if (owner_display_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_display_name_;
    owner_display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_owner_display_name(::std::string* owner_display_name) {
  if (owner_display_name_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_display_name_;
  }
  if (owner_display_name) {
    set_has_owner_display_name();
    owner_display_name_ = owner_display_name;
  } else {
    clear_has_owner_display_name();
    owner_display_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float world_x = 6;
inline bool SWGEmuStructureItemDetails::has_world_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_world_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SWGEmuStructureItemDetails::clear_has_world_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SWGEmuStructureItemDetails::clear_world_x() {
  world_x_ = 0;
  clear_has_world_x();
}
inline float SWGEmuStructureItemDetails::world_x() const {
  return world_x_;
}
inline void SWGEmuStructureItemDetails::set_world_x(float value) {
  set_has_world_x();
  world_x_ = value;
}

// optional float world_y = 7;
inline bool SWGEmuStructureItemDetails::has_world_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_world_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SWGEmuStructureItemDetails::clear_has_world_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SWGEmuStructureItemDetails::clear_world_y() {
  world_y_ = 0;
  clear_has_world_y();
}
inline float SWGEmuStructureItemDetails::world_y() const {
  return world_y_;
}
inline void SWGEmuStructureItemDetails::set_world_y(float value) {
  set_has_world_y();
  world_y_ = value;
}

// optional float world_z = 8;
inline bool SWGEmuStructureItemDetails::has_world_z() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_world_z() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SWGEmuStructureItemDetails::clear_has_world_z() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SWGEmuStructureItemDetails::clear_world_z() {
  world_z_ = 0;
  clear_has_world_z();
}
inline float SWGEmuStructureItemDetails::world_z() const {
  return world_z_;
}
inline void SWGEmuStructureItemDetails::set_world_z(float value) {
  set_has_world_z();
  world_z_ = value;
}

// optional string zone = 9;
inline bool SWGEmuStructureItemDetails::has_zone() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_zone() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SWGEmuStructureItemDetails::clear_has_zone() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SWGEmuStructureItemDetails::clear_zone() {
  if (zone_ != &::google::protobuf::internal::kEmptyString) {
    zone_->clear();
  }
  clear_has_zone();
}
inline const ::std::string& SWGEmuStructureItemDetails::zone() const {
  return *zone_;
}
inline void SWGEmuStructureItemDetails::set_zone(const ::std::string& value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_zone(const char* value) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_zone(const char* value, size_t size) {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  zone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_zone() {
  set_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    zone_ = new ::std::string;
  }
  return zone_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_zone() {
  clear_has_zone();
  if (zone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = zone_;
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_zone(::std::string* zone) {
  if (zone_ != &::google::protobuf::internal::kEmptyString) {
    delete zone_;
  }
  if (zone) {
    set_has_zone();
    zone_ = zone;
  } else {
    clear_has_zone();
    zone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 power = 10;
inline bool SWGEmuStructureItemDetails::has_power() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_power() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SWGEmuStructureItemDetails::clear_has_power() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SWGEmuStructureItemDetails::clear_power() {
  power_ = 0;
  clear_has_power();
}
inline ::google::protobuf::int32 SWGEmuStructureItemDetails::power() const {
  return power_;
}
inline void SWGEmuStructureItemDetails::set_power(::google::protobuf::int32 value) {
  set_has_power();
  power_ = value;
}

// optional int32 maintenance = 11;
inline bool SWGEmuStructureItemDetails::has_maintenance() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_maintenance() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SWGEmuStructureItemDetails::clear_has_maintenance() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SWGEmuStructureItemDetails::clear_maintenance() {
  maintenance_ = 0;
  clear_has_maintenance();
}
inline ::google::protobuf::int32 SWGEmuStructureItemDetails::maintenance() const {
  return maintenance_;
}
inline void SWGEmuStructureItemDetails::set_maintenance(::google::protobuf::int32 value) {
  set_has_maintenance();
  maintenance_ = value;
}

// optional int32 decay_percent = 12;
inline bool SWGEmuStructureItemDetails::has_decay_percent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_decay_percent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SWGEmuStructureItemDetails::clear_has_decay_percent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SWGEmuStructureItemDetails::clear_decay_percent() {
  decay_percent_ = 0;
  clear_has_decay_percent();
}
inline ::google::protobuf::int32 SWGEmuStructureItemDetails::decay_percent() const {
  return decay_percent_;
}
inline void SWGEmuStructureItemDetails::set_decay_percent(::google::protobuf::int32 value) {
  set_has_decay_percent();
  decay_percent_ = value;
}

// optional int32 lot_size = 13;
inline bool SWGEmuStructureItemDetails::has_lot_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_lot_size() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SWGEmuStructureItemDetails::clear_has_lot_size() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SWGEmuStructureItemDetails::clear_lot_size() {
  lot_size_ = 0;
  clear_has_lot_size();
}
inline ::google::protobuf::int32 SWGEmuStructureItemDetails::lot_size() const {
  return lot_size_;
}
inline void SWGEmuStructureItemDetails::set_lot_size(::google::protobuf::int32 value) {
  set_has_lot_size();
  lot_size_ = value;
}

// optional string template_file_name = 14;
inline bool SWGEmuStructureItemDetails::has_template_file_name() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_template_file_name() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SWGEmuStructureItemDetails::clear_has_template_file_name() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SWGEmuStructureItemDetails::clear_template_file_name() {
  if (template_file_name_ != &::google::protobuf::internal::kEmptyString) {
    template_file_name_->clear();
  }
  clear_has_template_file_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::template_file_name() const {
  return *template_file_name_;
}
inline void SWGEmuStructureItemDetails::set_template_file_name(const ::std::string& value) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_template_file_name(const char* value) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_template_file_name(const char* value, size_t size) {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  template_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_template_file_name() {
  set_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    template_file_name_ = new ::std::string;
  }
  return template_file_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_template_file_name() {
  clear_has_template_file_name();
  if (template_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = template_file_name_;
    template_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_template_file_name(::std::string* template_file_name) {
  if (template_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete template_file_name_;
  }
  if (template_file_name) {
    set_has_template_file_name();
    template_file_name_ = template_file_name;
  } else {
    clear_has_template_file_name();
    template_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string portals_file_name = 15;
inline bool SWGEmuStructureItemDetails::has_portals_file_name() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_portals_file_name() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SWGEmuStructureItemDetails::clear_has_portals_file_name() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SWGEmuStructureItemDetails::clear_portals_file_name() {
  if (portals_file_name_ != &::google::protobuf::internal::kEmptyString) {
    portals_file_name_->clear();
  }
  clear_has_portals_file_name();
}
inline const ::std::string& SWGEmuStructureItemDetails::portals_file_name() const {
  return *portals_file_name_;
}
inline void SWGEmuStructureItemDetails::set_portals_file_name(const ::std::string& value) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_portals_file_name(const char* value) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(value);
}
inline void SWGEmuStructureItemDetails::set_portals_file_name(const char* value, size_t size) {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  portals_file_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_portals_file_name() {
  set_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    portals_file_name_ = new ::std::string;
  }
  return portals_file_name_;
}
inline ::std::string* SWGEmuStructureItemDetails::release_portals_file_name() {
  clear_has_portals_file_name();
  if (portals_file_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = portals_file_name_;
    portals_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SWGEmuStructureItemDetails::set_allocated_portals_file_name(::std::string* portals_file_name) {
  if (portals_file_name_ != &::google::protobuf::internal::kEmptyString) {
    delete portals_file_name_;
  }
  if (portals_file_name) {
    set_has_portals_file_name();
    portals_file_name_ = portals_file_name;
  } else {
    clear_has_portals_file_name();
    portals_file_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string buildable_zones = 16;
inline int SWGEmuStructureItemDetails::buildable_zones_size() const {
  return buildable_zones_.size();
}
inline void SWGEmuStructureItemDetails::clear_buildable_zones() {
  buildable_zones_.Clear();
}
inline const ::std::string& SWGEmuStructureItemDetails::buildable_zones(int index) const {
  return buildable_zones_.Get(index);
}
inline ::std::string* SWGEmuStructureItemDetails::mutable_buildable_zones(int index) {
  return buildable_zones_.Mutable(index);
}
inline void SWGEmuStructureItemDetails::set_buildable_zones(int index, const ::std::string& value) {
  buildable_zones_.Mutable(index)->assign(value);
}
inline void SWGEmuStructureItemDetails::set_buildable_zones(int index, const char* value) {
  buildable_zones_.Mutable(index)->assign(value);
}
inline void SWGEmuStructureItemDetails::set_buildable_zones(int index, const char* value, size_t size) {
  buildable_zones_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SWGEmuStructureItemDetails::add_buildable_zones() {
  return buildable_zones_.Add();
}
inline void SWGEmuStructureItemDetails::add_buildable_zones(const ::std::string& value) {
  buildable_zones_.Add()->assign(value);
}
inline void SWGEmuStructureItemDetails::add_buildable_zones(const char* value) {
  buildable_zones_.Add()->assign(value);
}
inline void SWGEmuStructureItemDetails::add_buildable_zones(const char* value, size_t size) {
  buildable_zones_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SWGEmuStructureItemDetails::buildable_zones() const {
  return buildable_zones_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SWGEmuStructureItemDetails::mutable_buildable_zones() {
  return &buildable_zones_;
}

// optional .swgemurpcserver.rpc.BuildingItemDetails building_details = 20;
inline bool SWGEmuStructureItemDetails::has_building_details() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_building_details() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SWGEmuStructureItemDetails::clear_has_building_details() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SWGEmuStructureItemDetails::clear_building_details() {
  if (building_details_ != NULL) building_details_->::swgemurpcserver::rpc::BuildingItemDetails::Clear();
  clear_has_building_details();
}
inline const ::swgemurpcserver::rpc::BuildingItemDetails& SWGEmuStructureItemDetails::building_details() const {
  return building_details_ != NULL ? *building_details_ : *default_instance_->building_details_;
}
inline ::swgemurpcserver::rpc::BuildingItemDetails* SWGEmuStructureItemDetails::mutable_building_details() {
  set_has_building_details();
  if (building_details_ == NULL) building_details_ = new ::swgemurpcserver::rpc::BuildingItemDetails;
  return building_details_;
}
inline ::swgemurpcserver::rpc::BuildingItemDetails* SWGEmuStructureItemDetails::release_building_details() {
  clear_has_building_details();
  ::swgemurpcserver::rpc::BuildingItemDetails* temp = building_details_;
  building_details_ = NULL;
  return temp;
}
inline void SWGEmuStructureItemDetails::set_allocated_building_details(::swgemurpcserver::rpc::BuildingItemDetails* building_details) {
  delete building_details_;
  building_details_ = building_details;
  if (building_details) {
    set_has_building_details();
  } else {
    clear_has_building_details();
  }
}

// optional .swgemurpcserver.rpc.InstallationItemDetails installation_details = 21;
inline bool SWGEmuStructureItemDetails::has_installation_details() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SWGEmuStructureItemDetails::set_has_installation_details() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SWGEmuStructureItemDetails::clear_has_installation_details() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SWGEmuStructureItemDetails::clear_installation_details() {
  if (installation_details_ != NULL) installation_details_->::swgemurpcserver::rpc::InstallationItemDetails::Clear();
  clear_has_installation_details();
}
inline const ::swgemurpcserver::rpc::InstallationItemDetails& SWGEmuStructureItemDetails::installation_details() const {
  return installation_details_ != NULL ? *installation_details_ : *default_instance_->installation_details_;
}
inline ::swgemurpcserver::rpc::InstallationItemDetails* SWGEmuStructureItemDetails::mutable_installation_details() {
  set_has_installation_details();
  if (installation_details_ == NULL) installation_details_ = new ::swgemurpcserver::rpc::InstallationItemDetails;
  return installation_details_;
}
inline ::swgemurpcserver::rpc::InstallationItemDetails* SWGEmuStructureItemDetails::release_installation_details() {
  clear_has_installation_details();
  ::swgemurpcserver::rpc::InstallationItemDetails* temp = installation_details_;
  installation_details_ = NULL;
  return temp;
}
inline void SWGEmuStructureItemDetails::set_allocated_installation_details(::swgemurpcserver::rpc::InstallationItemDetails* installation_details) {
  delete installation_details_;
  installation_details_ = installation_details;
  if (installation_details) {
    set_has_installation_details();
  } else {
    clear_has_installation_details();
  }
}

// -------------------------------------------------------------------

// BuildingItemDetails

// repeated .swgemurpcserver.rpc.CharacterInventoryItem contained_items = 1;
inline int BuildingItemDetails::contained_items_size() const {
  return contained_items_.size();
}
inline void BuildingItemDetails::clear_contained_items() {
  contained_items_.Clear();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& BuildingItemDetails::contained_items(int index) const {
  return contained_items_.Get(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* BuildingItemDetails::mutable_contained_items(int index) {
  return contained_items_.Mutable(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* BuildingItemDetails::add_contained_items() {
  return contained_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
BuildingItemDetails::contained_items() const {
  return contained_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
BuildingItemDetails::mutable_contained_items() {
  return &contained_items_;
}

// -------------------------------------------------------------------

// InstallationItemDetails

// required bool operating = 1;
inline bool InstallationItemDetails::has_operating() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InstallationItemDetails::set_has_operating() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InstallationItemDetails::clear_has_operating() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InstallationItemDetails::clear_operating() {
  operating_ = false;
  clear_has_operating();
}
inline bool InstallationItemDetails::operating() const {
  return operating_;
}
inline void InstallationItemDetails::set_operating(bool value) {
  set_has_operating();
  operating_ = value;
}

// required float actual_rate = 2;
inline bool InstallationItemDetails::has_actual_rate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InstallationItemDetails::set_has_actual_rate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InstallationItemDetails::clear_has_actual_rate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InstallationItemDetails::clear_actual_rate() {
  actual_rate_ = 0;
  clear_has_actual_rate();
}
inline float InstallationItemDetails::actual_rate() const {
  return actual_rate_;
}
inline void InstallationItemDetails::set_actual_rate(float value) {
  set_has_actual_rate();
  actual_rate_ = value;
}

// required float max_hopper_size = 3;
inline bool InstallationItemDetails::has_max_hopper_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InstallationItemDetails::set_has_max_hopper_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InstallationItemDetails::clear_has_max_hopper_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InstallationItemDetails::clear_max_hopper_size() {
  max_hopper_size_ = 0;
  clear_has_max_hopper_size();
}
inline float InstallationItemDetails::max_hopper_size() const {
  return max_hopper_size_;
}
inline void InstallationItemDetails::set_max_hopper_size(float value) {
  set_has_max_hopper_size();
  max_hopper_size_ = value;
}

// optional .swgemurpcserver.rpc.HarvesterItemDetails harvester_details = 4;
inline bool InstallationItemDetails::has_harvester_details() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InstallationItemDetails::set_has_harvester_details() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InstallationItemDetails::clear_has_harvester_details() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InstallationItemDetails::clear_harvester_details() {
  if (harvester_details_ != NULL) harvester_details_->::swgemurpcserver::rpc::HarvesterItemDetails::Clear();
  clear_has_harvester_details();
}
inline const ::swgemurpcserver::rpc::HarvesterItemDetails& InstallationItemDetails::harvester_details() const {
  return harvester_details_ != NULL ? *harvester_details_ : *default_instance_->harvester_details_;
}
inline ::swgemurpcserver::rpc::HarvesterItemDetails* InstallationItemDetails::mutable_harvester_details() {
  set_has_harvester_details();
  if (harvester_details_ == NULL) harvester_details_ = new ::swgemurpcserver::rpc::HarvesterItemDetails;
  return harvester_details_;
}
inline ::swgemurpcserver::rpc::HarvesterItemDetails* InstallationItemDetails::release_harvester_details() {
  clear_has_harvester_details();
  ::swgemurpcserver::rpc::HarvesterItemDetails* temp = harvester_details_;
  harvester_details_ = NULL;
  return temp;
}
inline void InstallationItemDetails::set_allocated_harvester_details(::swgemurpcserver::rpc::HarvesterItemDetails* harvester_details) {
  delete harvester_details_;
  harvester_details_ = harvester_details;
  if (harvester_details) {
    set_has_harvester_details();
  } else {
    clear_has_harvester_details();
  }
}

// optional .swgemurpcserver.rpc.FactoryItemDetails factory_details = 5;
inline bool InstallationItemDetails::has_factory_details() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InstallationItemDetails::set_has_factory_details() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InstallationItemDetails::clear_has_factory_details() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InstallationItemDetails::clear_factory_details() {
  if (factory_details_ != NULL) factory_details_->::swgemurpcserver::rpc::FactoryItemDetails::Clear();
  clear_has_factory_details();
}
inline const ::swgemurpcserver::rpc::FactoryItemDetails& InstallationItemDetails::factory_details() const {
  return factory_details_ != NULL ? *factory_details_ : *default_instance_->factory_details_;
}
inline ::swgemurpcserver::rpc::FactoryItemDetails* InstallationItemDetails::mutable_factory_details() {
  set_has_factory_details();
  if (factory_details_ == NULL) factory_details_ = new ::swgemurpcserver::rpc::FactoryItemDetails;
  return factory_details_;
}
inline ::swgemurpcserver::rpc::FactoryItemDetails* InstallationItemDetails::release_factory_details() {
  clear_has_factory_details();
  ::swgemurpcserver::rpc::FactoryItemDetails* temp = factory_details_;
  factory_details_ = NULL;
  return temp;
}
inline void InstallationItemDetails::set_allocated_factory_details(::swgemurpcserver::rpc::FactoryItemDetails* factory_details) {
  delete factory_details_;
  factory_details_ = factory_details;
  if (factory_details) {
    set_has_factory_details();
  } else {
    clear_has_factory_details();
  }
}

// repeated .swgemurpcserver.rpc.CharacterInventoryItem hopper_items = 10;
inline int InstallationItemDetails::hopper_items_size() const {
  return hopper_items_.size();
}
inline void InstallationItemDetails::clear_hopper_items() {
  hopper_items_.Clear();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& InstallationItemDetails::hopper_items(int index) const {
  return hopper_items_.Get(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* InstallationItemDetails::mutable_hopper_items(int index) {
  return hopper_items_.Mutable(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* InstallationItemDetails::add_hopper_items() {
  return hopper_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
InstallationItemDetails::hopper_items() const {
  return hopper_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
InstallationItemDetails::mutable_hopper_items() {
  return &hopper_items_;
}

// -------------------------------------------------------------------

// HarvesterItemDetails

// required float extraction_rate = 1;
inline bool HarvesterItemDetails::has_extraction_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HarvesterItemDetails::set_has_extraction_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HarvesterItemDetails::clear_has_extraction_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HarvesterItemDetails::clear_extraction_rate() {
  extraction_rate_ = 0;
  clear_has_extraction_rate();
}
inline float HarvesterItemDetails::extraction_rate() const {
  return extraction_rate_;
}
inline void HarvesterItemDetails::set_extraction_rate(float value) {
  set_has_extraction_rate();
  extraction_rate_ = value;
}

// -------------------------------------------------------------------

// FactoryItemDetails

// optional .swgemurpcserver.rpc.CharacterInventoryItem schematic = 1;
inline bool FactoryItemDetails::has_schematic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FactoryItemDetails::set_has_schematic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FactoryItemDetails::clear_has_schematic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FactoryItemDetails::clear_schematic() {
  if (schematic_ != NULL) schematic_->::swgemurpcserver::rpc::CharacterInventoryItem::Clear();
  clear_has_schematic();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& FactoryItemDetails::schematic() const {
  return schematic_ != NULL ? *schematic_ : *default_instance_->schematic_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryItemDetails::mutable_schematic() {
  set_has_schematic();
  if (schematic_ == NULL) schematic_ = new ::swgemurpcserver::rpc::CharacterInventoryItem;
  return schematic_;
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryItemDetails::release_schematic() {
  clear_has_schematic();
  ::swgemurpcserver::rpc::CharacterInventoryItem* temp = schematic_;
  schematic_ = NULL;
  return temp;
}
inline void FactoryItemDetails::set_allocated_schematic(::swgemurpcserver::rpc::CharacterInventoryItem* schematic) {
  delete schematic_;
  schematic_ = schematic;
  if (schematic) {
    set_has_schematic();
  } else {
    clear_has_schematic();
  }
}

// repeated .swgemurpcserver.rpc.CharacterInventoryItem ingredient_items = 10;
inline int FactoryItemDetails::ingredient_items_size() const {
  return ingredient_items_.size();
}
inline void FactoryItemDetails::clear_ingredient_items() {
  ingredient_items_.Clear();
}
inline const ::swgemurpcserver::rpc::CharacterInventoryItem& FactoryItemDetails::ingredient_items(int index) const {
  return ingredient_items_.Get(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryItemDetails::mutable_ingredient_items(int index) {
  return ingredient_items_.Mutable(index);
}
inline ::swgemurpcserver::rpc::CharacterInventoryItem* FactoryItemDetails::add_ingredient_items() {
  return ingredient_items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >&
FactoryItemDetails::ingredient_items() const {
  return ingredient_items_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::CharacterInventoryItem >*
FactoryItemDetails::mutable_ingredient_items() {
  return &ingredient_items_;
}

// -------------------------------------------------------------------

// GetStructureItemDetailsRequest

// required fixed64 object_id = 1;
inline bool GetStructureItemDetailsRequest::has_object_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetStructureItemDetailsRequest::set_has_object_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetStructureItemDetailsRequest::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetStructureItemDetailsRequest::clear_object_id() {
  object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_id();
}
inline ::google::protobuf::uint64 GetStructureItemDetailsRequest::object_id() const {
  return object_id_;
}
inline void GetStructureItemDetailsRequest::set_object_id(::google::protobuf::uint64 value) {
  set_has_object_id();
  object_id_ = value;
}

// optional fixed64 owner_object_id = 2;
inline bool GetStructureItemDetailsRequest::has_owner_object_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetStructureItemDetailsRequest::set_has_owner_object_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetStructureItemDetailsRequest::clear_has_owner_object_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetStructureItemDetailsRequest::clear_owner_object_id() {
  owner_object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_owner_object_id();
}
inline ::google::protobuf::uint64 GetStructureItemDetailsRequest::owner_object_id() const {
  return owner_object_id_;
}
inline void GetStructureItemDetailsRequest::set_owner_object_id(::google::protobuf::uint64 value) {
  set_has_owner_object_id();
  owner_object_id_ = value;
}

// -------------------------------------------------------------------

// GetStructureItemDetailsResponse

// repeated .swgemurpcserver.rpc.SWGEmuStructureItemDetails structures = 1;
inline int GetStructureItemDetailsResponse::structures_size() const {
  return structures_.size();
}
inline void GetStructureItemDetailsResponse::clear_structures() {
  structures_.Clear();
}
inline const ::swgemurpcserver::rpc::SWGEmuStructureItemDetails& GetStructureItemDetailsResponse::structures(int index) const {
  return structures_.Get(index);
}
inline ::swgemurpcserver::rpc::SWGEmuStructureItemDetails* GetStructureItemDetailsResponse::mutable_structures(int index) {
  return structures_.Mutable(index);
}
inline ::swgemurpcserver::rpc::SWGEmuStructureItemDetails* GetStructureItemDetailsResponse::add_structures() {
  return structures_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::SWGEmuStructureItemDetails >&
GetStructureItemDetailsResponse::structures() const {
  return structures_;
}
inline ::google::protobuf::RepeatedPtrField< ::swgemurpcserver::rpc::SWGEmuStructureItemDetails >*
GetStructureItemDetailsResponse::mutable_structures() {
  return &structures_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace rpc
}  // namespace swgemurpcserver

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_StructureDetails_2eproto__INCLUDED
